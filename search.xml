<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Manjaro Linux + i3wm心得]]></title>
    <url>%2F2018%2F07%2F28%2Fmanjaro-i3wm%2F</url>
    <content type="text"><![CDATA[所有的熟悉都是从陌生开始的。 在使用3个月manjaro linux +i3wm之后我打算写一篇文章来记录一下心得,首先说一下，这篇文章并不是教程，只是分享一下使用心得。在这几个月使用期间，从刚开始的懵，到最后熟练使用效率大大提升，以至于使用gnome 或者windows桌面的时候各种不适应接下来会分成两部分来写，第一部分是manjaro linux，第二部分是i3wm。 一、基于arch的manjaro linux在使用Manjaro之前使用了大约1个月时间的Deepin Linux，界面确实很华丽漂亮，但是在Deepin的下面很多界面会有卡顿的感觉，比如启动器界面，以及多任务切换的时候，还有一个重要原因：我的蓝牙耳机 Fiil Diva 连上之后断断续续，基本不能用，而在Manjaro下面可以完美使用。 1.1 常用软件1.1.1 开发工具 java开发环境 使用yarout 终于可以拜托了debian系列繁琐的配置了，只需要无脑 yaourt intellij idea java开发必备 switchhosts 切换各个开发环境的hosts vscode postman sublime 基本上就使用vscode了，然而在编辑一些文本的时候vscode还是会卡顿，这个时候就要祭出sublime text了 xfce-terminal 我选择使用xfce-terminal 而不是uvxrt的原因是因为简单，而且字体展示更加优美，还可以方便的设置背景透明 1.1.2 日常使用 scrot 截屏软件 virtualbox 虚拟机，不管怎么样，在linux里面，虚拟机还是需要的，因为一些办公软件必须在windows下面才能使用。-1.2 命令行工具 1.2.1 命令行文件管理：ranger 1设置代理作为一个程序员，命令行上面有些资源难免要出墙，如果不用代理网速有些资源可能是龟速，比如yaourt某些软件的时候。如果你使用ss作为代理，可以使用alias给命令行设置代理。使用setproxy给命令行设置全局代理，使用完成之后在使用unsetproxy来取消代理。可以把下面三句话放到你的 .zshrc里面，这样随时随地就都能使用了。123alias setproxy="export ALL_PROXY=socks5://127.0.0.1:1080"alias unsetproxy="unset ALL_PROXY"alias ip="curl -i http://ip.cn" 二、 i3wm在使用i3wm之前，我知道的linux桌面有 gnome,cinnamon,kde,xfce等，对了还有国产的dde，这些桌面都有一个特点，就是和windows类似的，浮动窗口管理器，一个窗口可以浮在另外一个窗口上面，所以要在多个窗口间切换，则需要使用 alt+tab来回切换如果窗口少还好，如果窗口多的话，来回切换会非常繁琐，直到遇到了 平铺式窗口管理器i3wm。i3wm的所有窗口都平铺在桌面上，可以按照你的需求平铺或堆叠。初学起来可能配置麻烦，但是一点点熟悉下来会发现熟悉了根本离不开了，就如开头说的那样，所有的熟悉都是从陌生开始的。放一张截图： 关于i3wm的配置，就不写太多了，就推荐一个视频教程就够了教程地址：i3wm configuration附上我的配置文件地址：https://github.com/javaor/dot_files/tree/master/i3]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年的味道]]></title>
    <url>%2F2018%2F02%2F23%2Fnew-year-2018%2F</url>
    <content type="text"><![CDATA[年越来越近，年味却越来越淡了。 上小学的时候，放寒假的那一天，全体师生总要开个大会，期末考试的颁奖礼仪结束后，校长会强调一下假期里的安全事项，然后大声宣布放假了，那一瞬间，年就开始了。 寒假总是比暑假要舒服，因为寒假作业要更薄一点，过年还能吃到平时不能吃的东西，穿崭新的衣服，崭新的球鞋，新衣服还一定要在大年初一穿，现在想来应该算是一种仪式吧。新衣服一般都是集市上十几块或者几十块一身的衣服，从一年级到五年级，从公安制服到警察制服到小西装，流行穿什么我们就买什么，一到过年，一到大年初一，大街上跑的都是穿公安或者警察衣服的小孩子。下面还必须配一双帅气的足球鞋，一般是十几块的样子，下跑起来倍儿快。 想起来最幸福的事情莫过于和爸妈一起去赶集了，倒不是说集上有多好玩，只不过是因为在路上可以奢侈一把，买一个很酥的油饼。还会买对联，买几挂鞭炮，一般叫精装大地红。一千响或者两千响，后来可能是五千响的。我呢就偷偷的把大地红上面的炮仗一个一个小心拆下来，不过我也不敢全拆，一挂鞭上拆点，然后收集起来，几百个揣到兜里面，然后点一根香，在野外的田地里，沟渠旁，一个一个的放，扔到水里，放到砖缝里，扔到酒瓶里。。。这一切现在看来毫无意义，当时能玩一天乐此不疲。 我一般都喜欢把寒假作业都写完了，再出去玩，因为这样玩的时候就不用想寒假作业的事情，才能痛痛快快的玩。天气好的时候就搬个凳子在太阳下面写寒假作业，冬天的阳光晒着很是舒服。 升初中之后，过年肯定不能像小学那样了，过年的时候会跑到游戏厅打游戏，过一把不良少年的瘾。 到高中的时候，过年也就十几天的样子，过完年得赶紧回到学校继续用功读书，生怕自己考不上大学。过年的时候会赶庙会，看烟火，唱唱KTV等。 有些时候，觉得过去的时间会永远湮没在尘埃里，但是偶尔一个瞬间，一些记忆片段会浮现在眼前，虽然飘渺，不能触摸，但是却让人热泪盈眶。因为我们再也不能回到从前，作一个风度翩翩的此间少年。]]></content>
      <categories>
        <category>随笔散文</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【程序员摄影】之世博公园]]></title>
    <url>%2F2018%2F02%2F06%2Fphotograpy-in-shanghai%2F</url>
    <content type="text"><![CDATA[立春这一天本程序狗带着相机出门采风了，因为刚买的相机有点小兴奋。出了门才发现上海的冬天真不是盖的，天上的太阳仿佛是假的一般，冻的人瑟瑟发抖。风有点大，公园人不多，偶尔来个人也是跑步的，拿着我的fijifilm xt20随手拍的，感觉我仿佛买的事是假相机，照片跟手机拍的一样。 下面的照片都是直出，没有经过后期处理，还需要多加学习呀。]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年总结]]></title>
    <url>%2F2018%2F01%2F09%2Fsummery-2017%2F</url>
    <content type="text"><![CDATA[业务上，从刚开始对供应链几乎没什么了解，到现在基本上熟悉了供应链的各个环节，包括订单的正逆向流转的各个环节，库存包括一件货物的生命周期整个流转过程，采购到退仓，一退二退三退等，供应商部分:供应商入住，框架合同，品牌授权等。业务上能够及时向相关接口人咨询相关问题，通过代码反推业务逻辑的方式来熟悉整个业务流程，总结沉淀了订单履约相关的文档，熟悉了scm审批流的开发，以及解决遇到的各种问题。 技术上，也没有懈怠过，在业余时间研究学习了tmf框架以及hsf框架的源代码，窥探框架的演变过程，以及里面所用到的设计模式，或者反模式，吸收良好的编程思想，当然这是个很复杂而又漫长的过程，而且学来为所用也需要假以时日，但是学习的过程是不能停止的。生命不止，编程不息。最近也有在看一些书，比如《Kafka技术内幕》，《Netty实战》，《Fluet Python》等都是很好的书，慢慢一点点的吃透。 生活上，最主要是规律的坚持运动，从一个160斤的胖子变了一个140多斤的胖子，参加了1次杭州马拉松，很享受运动的过程，以后还会一直继续。 个人的规划方面，最近几年肯定都是以技术为主，而且也喜欢技术，喜欢折腾，最近3年之内肯定都是增强自己的技术水平。当然也不只是全是技术，人生也不只是技术，大部分情况下，技术是靠业务驱动的，没有业务，技术一毛钱不值，必须是掺了业务的技术，虽然个人的努力在整个浪潮之下作用不大，而且无法改变整体局势。未来的方向一定是对某个业务很熟悉 ，然后对相关业务的，技术的整个架构，甚至底层都很熟悉，我觉得这样也很酷。追求程序的自动化，配置化，健壮性，高吞吐等，当然也要跟上时代的潮流学习AI技术，万一以后AI时机真的成熟了，说不定真的不需要一堆一堆的前后端程序员了呢，一切皆有可能，时常保留一点危机意识，大厂程序员是螺丝钉，小厂程序员干杂活，这话不假，当然如果一味的自己拧螺丝未免单调了些，如果能够发现拧螺丝的之外的过程，熟悉每一个步骤，在懂了how之后再问个what，最后在问个why，如果每个问题自己都能够这样的解决了，那么你就不只是一个螺丝钉了，环境会有一些因素，关键在个人。 对于scm团队的建议： 可以进行code review，互相review，能够尽可能少的降低低级bug的产生 技术分享，每隔一段时间，都准备一项技术或者一个功能展开一次分享活动，只有在讲述的过程中才会知道自己有哪些不足。 可以多组织活动，聚餐、烧烤、徒步旅行等，增强联络感情]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秋]]></title>
    <url>%2F2017%2F10%2F24%2Fremember-autumn%2F</url>
    <content type="text"><![CDATA[昨天是二十四节气的霜降，这才感觉到秋天的已经快要离我而去，因为霜降接下来就是立冬了，晚上出去跑步已经不能穿短袖短裤了，秋天，这个收获的季节，我收获了什么果实，我在想… 最近工作上的事情把自己压得够呛，从国庆节过来开始到现在，每天都保持在基本后半夜才能回家，而且回家还得在电脑面前工作一段时间，得到2点多才能睡觉，感觉身心俱疲，好在每件事情都会有个结局，这半个月来的折腾也让自己学到了好多东西，包括整个供应链的业务流程，以及里面的一些技术上的细节，有些东西如果自己看的话没有那么容易就看会，但是如果有东西逼着你看，逼着你学，那时候可能就学会了。 这段时间自己还在一直坚持运动，Keep上连续运动已经2个多月了，这是我最想感谢自己的地方，下下周就要参加杭州马拉松了，争取这两周也要多跑几次热热身，每天的锻炼也是必不可少的。 从8月来体重大约减下去了大约10斤，因为是从8月开始坚持晚上吃少点，如果是在公司吃的话就吃沙拉，如果没有沙拉的话就只吃菜，不吃米饭，感觉挺好的，晚上也不会饿，如果晚上运动的话，可能运动完会吃一点水果，我也没有刻意去控制自己的饮食，周末的时候该吃肉还是会炖肉吃，但是体重确是实打实的减下去了，十一放假回家的时候，妈妈说我瘦了，脸瘦了一圈，希望自己能继续加油，把自己的小肚子减下去。 看了美剧《冰与火之歌》并且成功把女票拉下水和我一起看，还有《白夜追凶》，从来不看犯罪悬疑恐怖的女票也看得津津有味，感觉自己特别有成就感。 编程上面，Python学习感觉平时够用了，但是高阶的东西，还是掌握不够，Java方面学习了Netty这个框架，不过感觉需要再做个项目巩固一下，另一方面也是锻炼自己，Java编程思想快撸一遍了，里面有好多关于Java的细节，真的很好，也让自己对Java有更加深刻的认识。在公司可以接触到很多外接不能接触到的中间件技术，希望自己能够加把劲，在工作之余，多多研究技术的实现，以及源码，让自己的能力水平更进一步，以后才能独当一面。 2017年已经过去了297天，还剩下两个月的时间，不得不感叹时间真的很容易流失，注意力特别容易被乱七八糟的东西吸引，看看2017年年初定下的目标，还有相当一部分还没有实现，真的感觉特别打脸，计划如果不去实践又有什么意义。 种一棵树最好的时间是十年前，其次是现在，过去的日子都过去吧，从现在开始，一切都还不太晚。]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom优秀package列表（持续更新）]]></title>
    <url>%2F2017%2F07%2F31%2Fmy-atom-packages%2F</url>
    <content type="text"><![CDATA[Atom,VSCode 都属于Electronic 构建的跨平台编辑器,Atom 属于Github，VSCode属于Microsoft，两个的开源软件在社区里都挺活跃，Sublime也挺好用的，特别是速度，完爆Atom，VSCode 速度要比Atom快不少，那为啥要用Atom呢因为Sublime在Windows上字体渲染惨不忍睹，特别是在25寸2k显示器上，字体大就发虚，所以在我的mac上sublime还是挺好用的，但是在windows上如果不是编辑大的文件（Atom打开大的文本兼职坑爹），在不讲速度的前提下，我也不用sublime，都用Atom，毕竟颜值即正义。 下面是我自己平时用的好用的Package列表： 工具file-icons让你的侧边栏和Tab更加美观，为每种文件类型都绘制了精美的图标，甩默认的好几条街。 Sublime Style Column SelectionAtom默认没有Block选择的功能，但是别怕，已经有包实现了这个功能，Sublime Style Column Selection 这个包可以让你像EditPlus一样编辑块文本，在windows下面按住alt然后鼠标选择就可以选择区块文件了 minimap预览所有的代码 pretty-json正如其名，美化json，比如你从服务器日志上copy下来的json报文，可以用它一键美化，也可以反向将Json压缩成一行。 highlight-selected双击的时候高亮你选择的单词，如果此单词在该文件中已经有了 也都会被高亮显示 语言script在Atom内运行代码，必备Package Python Autocomplete python自动提示，写python必备。 linter-pycodestyle记得先pip 安装pycodestyle插件然后再安装atom package 要不然一点击保存就会报错。安装的时候Atom会提示你其他的必须包，一起安装了就好。1pip install pycodestyle Python Tools快捷键ctrl+alt+u显示当前变量被调用的地方快捷键ctrl+alt+g显示定义的地方]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年中总结]]></title>
    <url>%2F2017%2F07%2F14%2Fsummary-in-middle-year%2F</url>
    <content type="text"><![CDATA[如约而至的七月，空气里充满了茂盛的味道，狂风、暴雨、烈日、蝉鸣… 分外怀念有暑假的日子。2017年已经过了一半，白天时间开始变短，下半年也逐渐开始了，是时候给自己的上半年总结一下了。总结是为了更好的了解自己的途径，成长也许就在不经意之间就发生了，同时也让下半年的目标更加有动力。总共会在三个维度上总结一下。 工作毕业已满三年，都说三年是一个坎，五年又是一个，所以其实感觉也是挺焦虑的，怕自己能力达不到，其实，但是其实和过去的自己比的话，还是成长很多的。工作最重要的事情是成长，在爱屋的一年来，感觉收获了很多，特别是熟悉了很多互联网公司用的产品，以及相关技术，虽然经历了很多不愉快的事情，调了N次作为，换了N次领导以后，我觉得爱屋也许并不适合我，我只想安安静静的写代码，想和厉害的人一起做很好的产品。 在6月份，我经历了面试月，基本天天的节奏就是，复习-面试-总结，循环不断的进行，上海本地的大部分公司基本都被我面过了，饿了么，美团，B站，一号店等…有失误的地方，但是还是收到了不少offer，在总结中才能更好的进步。 魅力惠是属于阿里的一个BU，所以要学的东西还挺多，都是阿里的那一套，很多高性能的中间件，今年下半年的最重要的任务就是深入框架内部学习，在公司工作是一方面，个人成长则是更加重要的事情。 生活上半年搬了一次家，有了专属的小窝（之前是合租），在宜家买了拉克边桌、地毯、鞋柜、凳子、衣架等，让房间更加有质感，和女朋友一起拼装家具，打扫房间，贴纸等，很开心，看到一个乱糟糟的房间变成井井有条的房间，感觉很有成就感有木有。 今年剁了好多手，买的东西不少，3月份买了kindle，6月份买了MacBook pro，这两个东西基本都是常常在我身边的东西，kinde解决了在地铁上慢慢长路，mac则让我爱上了触摸板，爱上写作，爱上编程。 春天和爱人一起去周庄、锦溪玩了一圈，很喜欢一起出去玩的感觉，不过以后不能只留下图片，还得多谢谢旅行日记，记录下一些体会感想等。 今年跑步没怎么坚持，只是偶尔会跑跑，健身倒是还行，会跟着Keep进行一些训练，出出汗，感觉和跑步差不多，身体最重要。 书618期间又屯了好几本书，够下半年看的了，加上之前买的没看完的书，现在在kindle上已经不囤积很多书了，看完一本再买下一本。其实上半年基本没读什么新的技术书，都是看以前的旧书，有些经典值得读N遍，比如java并发编程，重构等… 看过的书 黑客与画家（kindle） Java高并发程序设计 必然 失乐园（kindle，上面好多性描写很直白，看的我在地铁上好尴尬） 大型网站系统与java中间件实践 未来简史(kindle) 巨婴国(kindle) 正在看的书 Netty实战 Java编程思想 数据结构与算法分析Java描述 Java虚拟机规范 Python核心编程 傲慢与偏见 思考的艺术 Java8实战 总结有的时候很焦虑，是因为不能沉下心来看一本书，看着好多东西要学，总是会发憷，如果不去想那么多，书一点一点看，不和别人比只和过去的自己比，只要能看到自己的进步，就好了，想得多自己还累，上半年看了一些书，去了一些地方，收获了一些东西。]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自律与健康]]></title>
    <url>%2F2017%2F06%2F29%2Fhealth-and-self-discipline%2F</url>
    <content type="text"><![CDATA[自律给我自由 一直很喜欢Keep启动时splash上这句话，使用Keep这个软件也1年多了，想总结点东西。 其实最早用keep是2015年的8月，只不过那时候Keep还没有跑步的功能，而我也一直在用悦跑圈跑步，整个从2015年7月开始到2016年10月结束，总共运动了1200多公里，体重基本没怎么变化，应该是因为我不忌口的原因，运动量大吃的也多所以不会变瘦。 从16年10月开始从悦跑圈转到了Keep，报名了Keep的健身课程，练习了2个月，基本每天训练时间都大约30分钟，非常喜欢运动后大汗淋漓的感觉，但是跑步渐渐少了，早上起不来去跑步，晚上又要做健身，跑步就逐渐废掉了，2017年开始，渐渐捡起了跑步，虽然频率不高，但是每周总会运动几次，还是很喜欢运动过后的感觉，发发汗，洗洗澡，看书写代码的效率更高。 毕业已经三年，时间真的可怕，对于程序员来说，天天对着电脑，健康真的不能懈怠，该运动的时候就去运动吧，跑步也好，做plank也行，虐虐自己的身体后会爽的不亦乐乎。 仔细想想，习惯真的是很神奇的东西，比如上班，如果你刚开始通勤需要30分钟，那么如果换工作需要1个小时的话你会接受不了，但是如果适应几周之后你就习惯了，觉得自然了，习惯真的很重要，把运动当成一个习惯，而不是一个需要坚持的东西。 用心感受自我，去做每一个动作，去看每一行字，去写每一行代码，强大的自律是为了让自己更加自由的活。]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>自律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始自己的Mac人生]]></title>
    <url>%2F2017%2F06%2F18%2Fstart-programming-with-macbook%2F</url>
    <content type="text"><![CDATA[拥有一台mac应该算是从学生时代的愿望，但是苦于囊中羞涩，工作了之后想买但是自己又下不去狠心去买，618期间本来想入手15款的macbook pro，跟女朋友一说这个事情，她说要买就买最新款的，不差那几个钱，所以昨天就和她一起去南京东路苹果直营店买下了一台2017款的没有touch-bar的13寸MacBook Pro。随手拍两张图： 对于一个程序员，MacBook Pro绝对算是一个物超所值的生产力工具（赚钱工具），类unix的系统为开发提供了友好的开发环境，同时DE的稳定性又比Linux高出一大截。硬件方面，新款MacBook pro的第二代蝴蝶键盘感觉好像再敲击钢板，会有明显的反馈，所以手感还是不错的，但是如果要长期写代码的话，还是需要配一个机械键盘的。屏幕显示细腻，令人爱不释手。 晚上鼓捣了一晚上把电脑的开发环境搭好了，软件清单如下： 笔记：evernote+sublime-evernote插件可以在sublime中书写markdown文件并和evernote无缝集合 任务管理：滴答清单，谁用谁知道 命令行：iterm2 +zsh+homebrew+tmux+vim 词典：欧陆辞典，辞典中应该算很良心的了 软件开发：jdk 8+intellij idea+Datagrip+ Pycharm，基本都是Jetbrains家的，不过换了keymap之后又要重新适应了 编辑器：sublime+Atom 接口测试：postman 文档：Dash，海量离线文档API，异常强大,calibre用来管理电子书 云存储： 坚果云，国内最好用的云盘，存储日常生活的文档资料等绝对够用 下面是我安装好的软件截图：好的工具有了，接下来的事情就是用好这个工具创造价值，打怪升级了，程序员这条路并不好走，但是却很有趣，最后，感谢女票，很幸运有这么好的女朋友，在生活和工作中给我很多鼓舞和支持，马上就要领证了，希望能和她一起走下去。 就先写着么多吧，继续研究java虚拟机去了。 一些软件参考自这里：awesome-mac]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[intellij idea中使用javap等JDK工具]]></title>
    <url>%2F2017%2F04%2F17%2Fintellij-external-tools%2F</url>
    <content type="text"><![CDATA[java工程师平时工作中用到的工具挺多的，比如javap,jstack等，intellij idea 作为宇宙最强java ide idea一样可以帮我们实现这个功能，方法如下： ctrl+alt+s打开设置界面,找到Tool-&gt; External Tools 点击 +来增加一个新的外部工具。 在tool setting 的Program输入工具的路径，这中间可以插入宏，比如$JDK_PATH$，不需要自己再手动输入jdk的路径了，在Parameters中输入-c $FileClass$ ，$FileClass$代表要解析的 class文件,-c代表输出分解后的代码在Workding Directory中输入$OutputPath$,代表项目的输出路径 在java文件上右键，选择External Tools -&gt; javap就可以输入分解后的代码了，也可以自定义快捷键，比如设置alt+p就可以很方便的使用javap这个工具了，其他的工具和这个类似，都可以很方便的添加到External Tool里]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中final关键字总结]]></title>
    <url>%2F2017%2F04%2F17%2Ffinal-in-java%2F</url>
    <content type="text"><![CDATA[final在java中的用法有很多，可以修饰field，可以修饰Method，可以修饰Class，而且final在多线程环境中保证了对象状态的不变性，下面就系统的总结一下Java中final关键字的用法 修饰Variable/field 修饰primitive变量，变量一旦赋值就不再可变。 final修饰基本数据类型变量和String类型时，类似于C++的const 3种变量会被隐式的定义为final：3.1. 接口中的field是final的3.2. Java7中出现的try with resource语句中的变量是隐式的final类型,如下面的代码，inputStream虽然未被声明为final，但是如果试图在try块里面重新对inputStream赋值的话，就会产生编译异常，不能给final变量赋值 12345try (FileInputStream inputStream = new FileInputStream("text.txt"))&#123;inputStream = new FileInputStream("");&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 修饰引用实例类型变量，变量被赋值后，变量指向的引用的值可以变，但是不能重新指向新的引用，即final只关心引用本身，而不关心final引用的内容。 12345678public static void main(String[] args) &#123; final User user = new User("xuan1",23); System.out.println(user.getAge()); //输出23 user.setAge(24); System.out.println(user.getAge()); //输出24 user = new User("xuan2",25); //编译错误，提示不能赋值给final变量 System.out.println(user.getAge());&#125; 修饰实例成员变量时，必须在定义的时候初始化：直接赋值，构造器初始化，或代码块中初始化，或的意思是这三种方式只能选择一种，否则编译报错。 修饰静态成员变量时，必须在变量定义的时候初始化：直接赋值，静态代码块中赋值 Tips: 有一种特殊情况：System.in,System.out,System.err 是静态域但是没有在定义的时候或者静态代码块中初始化，而是使用了set方法来设置值。 JDK8以前内部类访问外部类的变量时要求变量为Final类型,JDK8之后，只要求外部类为事实不可变变量，不一定要加上final 关于事实不可变final的定义： variable or parameter whose value is never changed after it is initialized is effectively final也就是说变量被初始化之后没有改变过即使没有final，jvm也会把这个变量解释为final类型来对待。 下面是官方文档的一个例子：在内部类PhoneNumber中的构造器中使用外部的numberLength的时候，JDK8之前必须显示定义为final类型，否则编译器将会给出警告，而在JDK8之后并不需要显式声明为final，但是，如果变量在初始化之后被再次赋值的话，就会出现异常了，因为打破了事实不可变的条件，所以在构造器中再次给numberLength赋值为7的时候，JDK8的编译器也给出了错误提示。同理，在printOriginalNumbers方法中方为外部类的变量phoneNumber1，phoneNumber2的时候JDK8以前的编译器给出错误提示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package io.github.javaor;/** * Created by zhaohongxuan */public class LocalClassExample &#123; static String regularExpression = "[^0-9]"; public static void validatePhoneNumber(String phoneNumber1, String phoneNumber2) &#123; int numberLength = 10; // Valid in JDK 8 and later: // int numberLength = 10; class PhoneNumber &#123; String formattedPhoneNumber = null; PhoneNumber(String phoneNumber) &#123;// numberLength = 7; String currentNumber = phoneNumber.replaceAll(regularExpression, ""); if (currentNumber.length() == numberLength) formattedPhoneNumber = currentNumber; else formattedPhoneNumber = null; &#125; public String getNumber() &#123; return formattedPhoneNumber; &#125; // Valid in JDK 8 and later: public void printOriginalNumbers() &#123; System.out.println("Original numbers are "+phoneNumber1+" and "+phoneNumber2); &#125; &#125; PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1); PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2); // Valid in JDK 8 and later:// myNumber1.printOriginalNumbers(); if (myNumber1.getNumber() == null) System.out.println("First number is invalid"); else System.out.println("First number is " + myNumber1.getNumber()); if (myNumber2.getNumber() == null) System.out.println("Second number is invalid"); else System.out.println("Second number is " + myNumber2.getNumber()); &#125; public static void main(String... args) &#123; validatePhoneNumber("123-456-7890", "456-7890"); &#125;&#125; 修饰MethodJava语言规范中的描述如下： A method can be declared final to prevent subclasses from overriding or hiding it.It is a compile-time error to attempt to override or hide a final method.A private method and all methods declared immediately within a final class (§8.1.1.2) behave as if they are final, since it is impossible to override them.At run time, a machine-code generator or optimizer can “inline” the body of a final method, replacing an invocation of the method with the code in its body. The inlining process must preserve the semantics of the method invocation. In particular, if the target of an instance method invocation is null, then a NullPointerException must be thrown even if the method is inlined. A Java compiler must ensure that the exception will be thrown at the correct point, so that the actual arguments to the method will be seen to have been evaluated in the correct order prior to the method invocation. final修饰方法可以阻止子类覆盖，如果试图覆盖则编译报错 private 方法和final 类的方法表现的为final方法的属性，因为无法覆盖他们。 运行时，JVM会内联final方法，用final方法的代码替换方法的调用，下图是一个简单示例: 12345678910111213final class Point &#123; int x, y; void move(int dx, int dy) &#123; x += dx; y += dy; &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Point[] p = new Point[100]; for (int i = 0; i &lt; p.length; i++) &#123; p[i] = new Point(); p[i].move(i, p.length-1-i); &#125; &#125;&#125; main方法里的for循环中的Point类中的move方法将会被内联为下面的代码： 1234567 for (int i = 0; i &lt; p.length; i++) &#123; p[i] = new Point(); Point pi = p[i]; int j = p.length-1-i; pi.x += i; pi.y += j;&#125; Header One Header Two Item One Item Two 参考资料：http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.3.3 修饰Class1. final修饰Class可以防止类被继承 2. final和abstract不能同时修饰类，因为2者是互斥的。 final的语义1. Java编译器允许final域缓存在寄存器中而不用重新加载它，如果是非fina域的话，将会被重新加载 2. final可以确保初始化过程中的安全性，不可变对象时线程安全的，在多个线程中共享这些对象无需同步。 3. 多线程中，一个对象的final域在一个线程的构造器结束的时候，在另外的线程中可见。java中有很多安全的特点都是依据String类是被设计为final来保证的 Java内存模型中的final TODO参考资料：http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.5]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中将JSON反序列化为泛型对象]]></title>
    <url>%2F2017%2F02%2F24%2Fjson-to-map-include-list%2F</url>
    <content type="text"><![CDATA[将嵌套List的Map转换为Json应该都没什么问题，使用Gson和Jackson都能实现，在Gson中使用new Gson().toJson()方法，在Jackson中使用new ObjectMapper().writeValueAsString()即可。将json转换为形如Map&lt;String,List&gt;的时候遇到了一点问题，虽然返回类型是Map&lt;String,List&lt;Long&gt;&gt;但是，Map的value的值却并不是List&lt;Long&gt;,而是Integer类型的，这里面显然是有问题的，查看Jackson的源码和Gson的源码发现将json反序列化为对象确实有两个方法，一种适用于泛型对象，一种适用于非泛型的一般对象。 使用Gson在gson中将json字符串转反序列化为对象有两个方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 /** * This method deserializes the specified Json into an object of the specified class. It is not * suitable to use if the specified class is a generic type since it will not have the generic * type information because of the Type Erasure feature of Java. Therefore, this method should not * be used if the desired type is a generic type. Note that this method works fine if the any of * the fields of the specified object are generics, just the object itself should not be a * generic type. For the cases when the object is of generic type, invoke * &#123;@link #fromJson(String, Type)&#125;. If you have the Json in a &#123;@link Reader&#125; instead of * a String, use &#123;@link #fromJson(Reader, Class)&#125; instead. * * @param &lt;T&gt; the type of the desired object * @param json the string from which the object is to be deserialized * @param classOfT the class of T * @return an object of type T from the string. Returns &#123;@code null&#125; if &#123;@code json&#125; is &#123;@code null&#125;. * @throws JsonSyntaxException if json is not a valid representation for an object of type * classOfT */public &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT) throws JsonSyntaxException &#123; Object object = fromJson(json, (Type) classOfT); return Primitives.wrap(classOfT).cast(object); &#125; /** * This method deserializes the specified Json into an object of the specified type. This method * is useful if the specified object is a generic type. For non-generic objects, use * &#123;@link #fromJson(String, Class)&#125; instead. If you have the Json in a &#123;@link Reader&#125; instead of * a String, use &#123;@link #fromJson(Reader, Type)&#125; instead. * * @param &lt;T&gt; the type of the desired object * @param json the string from which the object is to be deserialized * @param typeOfT The specific genericized type of src. You can obtain this type by using the * &#123;@link com.google.gson.reflect.TypeToken&#125; class. For example, to get the type for * &#123;@code Collection&lt;Foo&gt;&#125;, you should use: * &lt;pre&gt; * Type typeOfT = new TypeToken&amp;lt;Collection&amp;lt;Foo&amp;gt;&amp;gt;()&#123;&#125;.getType(); * &lt;/pre&gt; * @return an object of type T from the string. Returns &#123;@code null&#125; if &#123;@code json&#125; is &#123;@code null&#125;. * @throws JsonParseException if json is not a valid representation for an object of type typeOfT * @throws JsonSyntaxException if json is not a valid representation for an object of type */ @SuppressWarnings("unchecked") public &lt;T&gt; T fromJson(String json, Type typeOfT) throws JsonSyntaxException &#123; if (json == null) &#123; return null; &#125; StringReader reader = new StringReader(json); T target = (T) fromJson(reader, typeOfT); return target; &#125; 观察fromJson(String json, Class&lt;T&gt; classOfT)的注释： It is not suitable to use if the specified class is a generic type since it will not have the generic type information because of the Type Erasure feature of Java 也就是说，由于Java泛型的擦除机制，这个方法不适用于传入泛型的类，比如Map&lt;String,Long&gt;,List&lt;String&gt;等，这个时候可以用T fromJson(String json, Type typeOfT)替代。 下面还有一段话： Note that this method works fine if the any of the fields of the specified object are generics, just the object itself should not be a generic type 注意： 如果对象不是泛型的，只是字段是泛型的话这个方法是可以使用的 刚开始不太理解这句话，后来想通了，也就是类定义上不能带有泛型比如 public interface Map&lt;K,V&gt; 这样的就不行，但是如果是下面这样的只有域上带有的泛型是可以： 123456789101112static class JsonDemo&#123; private List&lt;Long&gt; list; public List&lt;Long&gt; getList() &#123; return list; &#125; public void setList(List&lt;Long&gt; list) &#123; this.list = list; &#125; &#125; 下面的fromJson(String json, Type typeOfT)就是专门提供给泛型类的对象使用的，如果你自己反序列化的对象带有泛型的话需要用这个方法。 使用Jackson和gson一样，jackson也提供了两个方法，一个适用于普通的类，一个适用于泛型类，只不过jackson源码的注释没有Gson的丰富，从注释上看不出来，功能和Gson的一致。 12345678910111213141516171819202122232425262728293031323334353637/** * Method to deserialize JSON content from given JSON content String. * * @throws IOException if a low-level I/O problem (unexpected end-of-input, * network error) occurs (passed through as-is without additional wrapping -- note * that this is one case where &#123;@link DeserializationFeature#WRAP_EXCEPTIONS&#125; * does NOT result in wrapping of exception even if enabled) * @throws JsonParseException if underlying input contains invalid content * of type &#123;@link JsonParser&#125; supports (JSON for default case) * @throws JsonMappingException if the input JSON structure does not match structure * expected for result type (or has other mismatch issues) */ @SuppressWarnings("unchecked") public &lt;T&gt; T readValue(String content, Class&lt;T&gt; valueType) throws IOException, JsonParseException, JsonMappingException &#123; return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType)); &#125; /** * Method to deserialize JSON content from given JSON content String. * * @throws IOException if a low-level I/O problem (unexpected end-of-input, * network error) occurs (passed through as-is without additional wrapping -- note * that this is one case where &#123;@link DeserializationFeature#WRAP_EXCEPTIONS&#125; * does NOT result in wrapping of exception even if enabled) * @throws JsonParseException if underlying input contains invalid content * of type &#123;@link JsonParser&#125; supports (JSON for default case) * @throws JsonMappingException if the input JSON structure does not match structure * expected for result type (or has other mismatch issues) */ @SuppressWarnings(&#123; "unchecked", "rawtypes" &#125;) public &lt;T&gt; T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException &#123; return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef)); &#125; 简单实验使用两种方式反序列一个json，使用Class来反序列化泛型类型的对象，在printType的时候会出现ClassCastException类型转换异常。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package org.xuan;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.collect.Maps;import com.google.common.reflect.TypeToken;import com.google.gson.Gson;import java.io.IOException;import java.util.Arrays;import java.util.List;import java.util.Map;/** * Created by zhaohongxuan */public class JsonTest &#123; private static ObjectMapper mapper = new ObjectMapper(); private static Gson gson = new Gson(); public static void main(String[] args) throws IOException &#123; Map&lt;String, List&lt;Long&gt;&gt; map = Maps.newHashMap(); map.put("one", Arrays.asList(10001L, 10002L, 10003L, 10004L)); map.put("two", Arrays.asList(20001L, 20002L, 20003L, 20004L)); map.put("three", Arrays.asList(30001L, 30002L, 30003L, 30004L)); map.put("four", Arrays.asList(40001L, 40002L, 40003L, 40004L)); String json = new Gson().toJson(map); System.err.println("=======================错误示范====================="); //Gson Map&lt;String, List&lt;Long&gt;&gt; mapResult = gson.fromJson(json,Map.class); System.out.println("通过Gson转换...");// printType(mapResult); System.out.println(mapResult); //Json Map&lt;String, List&lt;Long&gt;&gt; jsonMapResult = mapper.readValue(json,Map.class); System.out.println("通过Jackson转换...");// printType(jsonMapResult); System.out.println(jsonMapResult); System.out.println("=======================正确做法====================="); //Gson Map&lt;String, List&lt;Long&gt;&gt; mapResult1 = gson.fromJson(json,new TypeToken&lt;Map&lt;String, List&lt;Long&gt;&gt;&gt;()&#123;&#125;.getType()); System.out.println("通过Gson转换..."); printType(mapResult1); System.out.println(mapResult1); //Json ObjectMapper mapper = new ObjectMapper(); Map&lt;String, List&lt;Long&gt;&gt; jsonMapResult1 = mapper.readValue(json,new TypeReference&lt; Map&lt;String,List&lt;Long&gt;&gt;&gt;() &#123;&#125;); System.out.println("通过Jackson转换..."); printType(jsonMapResult1); System.out.println(jsonMapResult1); &#125; public static void printType(Map&lt;String, List&lt;Long&gt;&gt; map)&#123; for (Map.Entry&lt;String, List&lt;Long&gt;&gt; entry: map.entrySet())&#123; System.out.println("key 类型:"+entry.getKey().getClass()+", value类型:" +entry.getValue().getClass()+", List中元素类型"+entry.getValue().get(0).getClass()); &#125; &#125;&#125; 总 结在Gson中：如果使用fromJson(String json, Class&lt;T&gt; classOfT)来反序列化Map的话，不会造成编译错误，返回的类型就会变化，Long类型变成了Double类型,使用的时候就会出现异常，例如在遍历Map的entrySet的时候就会出现异常。 1java.lang.ClassCastException: java.lang.Double cannot be cast to java.lang.Long 因此： 反序列化泛型对象如Map&lt;K,V&gt;等需要使用 fromJson(String json, Type typeOfT) 一般对象使用fromJson(String json, Class&lt;T&gt; classOfT)在Jackson中：如果使用T readValue(String content, Class&lt;T&gt; valueType)来反序列化Map的话，返回的类型就会由Long类型变成了Integer类型。 反序列化泛型对象如Map&lt;K,V&gt;等需要使用 T readValue(String content, TypeReference valueTypeRef) 一般对象使用T readValue(String content, Class&lt;T&gt; valueType)]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017阅读计划]]></title>
    <url>%2F2017%2F02%2F02%2Freading-in-2017%2F</url>
    <content type="text"><![CDATA[总是等到过完农历的新年才会觉得新的一年才真正的开始，元旦仿佛没有什么卵用，回首过去的一年，有很多收获，同时也有不少遗憾，京东做活动的时候买的书还有好多没有读完，新的一年，新的开始，书要一步一步的读，代码要一字一字得码，希望2017年能够更上一层楼。下面的只是个大概的提纲，没有具体的每天读几页，多少天读完等很严格的规划，因为生活中有很多突发事件会影响自己，公司加班、生病发烧，聚餐啊，跳槽等等…无法预测，用尽一切时间去学：在地铁上看，在饭后看，睡觉前少看会儿手机多读一会儿书，让心流的时间加长，高效专注的完成之后再休息。 技术方面首先，肯定是要去库存，去年京东做活动买的没读完的书争取在上半年读完。No.1《Redis设计与实现》Redis不仅是一个缓存工具，而且还是一个nosql的实现，性能极其强大，目前No.2《编程珠玑》编程方面的属于元老级别的书吧，修炼自己的内功必备，想吃透这本书我觉得一年都不一定行。No.3《Spring实战》原本是买来给女朋友入门Spring的…我先撸一遍吧，里面的例子还是很清晰的，适合初学者，我更倾向于看《Spring揭密》。No.4《Linux命令行与shell脚本编程大全（第3版）》作为一个Java行业从业者，Linux自然是必不可少的，提高自己的Linux姿势水平势在必行。No.5《利用Python进行数据分析》去年读完了《Python基础教程》，还是应该投入实际的用途，学学用Python进行数据分析吧。No.6《高性能Mysql》这个板砖书，还是看电子版的好了，放在ipad里也极其方便，不一定全部看完，但是重要章节一定得看完，而且得熟练，互联网公司必备。No.7《敏捷软件开发原则、模式与实践》再重新读一遍此神书，了解如何编写优雅的代码。 其他方面No.1《设计中的设计》培养自己的审美水平，无印良品总设计师操刀的书，值得一看。No.2《人类简史》仰慕已久的书，历史佳作。No.3《梦的解析》很古老的一本书，心理学著作，希望自己能看的进去。No.4《国富论下》上册看完了，下册岂有不看之理No.5《三体》宏大的科幻奇书，互联网行业必看的，打算在地铁上刷完。No.6《世界简史》就是对历史有所偏爱，看完《人类简史》看世界简史，读史使人明智，称为更好的自己。No.7《必然》看完KK的《失控》，《必然》势在必看。]]></content>
      <categories>
        <category>杂文其他</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka入门]]></title>
    <url>%2F2017%2F01%2F19%2Fsimple-kafka-example%2F</url>
    <content type="text"><![CDATA[1.环境配置kafka依赖zookeeper来调度，以及选举leader，因此需要先安装zookeeper 1.1 安装zookeeper点击下载zookeeper下载合适版本的zookeeper，当前最新的稳定版本是3.4.9创建好数据目录,命名为data，下一步配置用到 12$ cd opt/ &amp;&amp; tar -zxf zookeeper-3.4.6.tar.gz &amp;&amp; cd zookeeper-3.4.6$ mkdir data 1.2 配置zookeeper123456$ vi conf/zoo.cfgtickTime=2000dataDir=/path/to/zookeeper/dataclientPort=2181initLimit=5syncLimit=2 1.3 启动zookeeper1$ bin/zkServer.sh start 相应的停止zookeeper的命令为： 1$ bin/zkServer.sh stop 1.4 启动zookeeper CLI1$ bin/zkCli.sh 1.2 安装kafka1.2.1 下载并解压点击下载kafka的压缩包123$ cd opt/$ tar -zxf kafka_2.11-0.10.1.0.tgz$ cd kafka_2.11-0.10.1.0 1.3.1 启动和关闭Kafka启动kafka1$ bin/kafka-server-start.sh config/server.properties 关闭kafka 1$ bin/kafka-server-stop.sh config/server.properties 2.测试单broker我的kafka服务创建在Linux虚拟机上，IP地址为：192.168.61.131（按需替换成自己的IP地址），在这里需要配置server.properties文件，将advertised.host.name设置为虚拟机的IP地址 advertised.host.name=192.168.61.131，否则在宿主机上无法访问虚拟机上面的服务 ###2.1 使用Shell命令测试topic 2.1.1 创建topic在命令行界面kafka目录，输入下面命令： 1bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic page_visits 2.1.2 测试发布者输入以下命令，打开发布消息CLI1bin/kafka-console-producer.sh --broker-list localhost:9092 --topic page_visits 在CLI界面输入，两行测试消息 Hello kafka 你好吗？ 2.1.3 测试订阅者输入一下命令打开订阅者CLI 1bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --zookeeper localhost:2181 --from-beginning --topic page_visits 如果执行正确，会显示刚才发布者发送的两行消息 ###2.2 使用Java代码创建Client来发布订阅消息 需要先在pom中添加kafka依赖： 12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.9.2&lt;/artifactId&gt; &lt;version&gt;0.8.1.1&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;jmxri&lt;/artifactId&gt; &lt;groupId&gt;com.sun.jmx&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;jms&lt;/artifactId&gt; &lt;groupId&gt;javax.jms&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;jmxtools&lt;/artifactId&gt; &lt;groupId&gt;com.sun.jdmk&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;0.9.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.2.1 创建发布者发布消息下面一段代码，会每隔3秒中发布一个测试消息 12345678910111213141516171819202122public class MyProducer &#123; private final static String TOPIC = "page_visits"; public static void main(String[] args) throws InterruptedException &#123; long events = 100; Properties properties = new Properties(); properties.put("metadata.broker.list", "192.168.61.131:9092"); properties.put("serializer.class", "kafka.serializer.StringEncoder"); ProducerConfig config = new ProducerConfig(properties); Producer&lt;String, String&gt; producer = new Producer&lt;String, String&gt;(config); for (long nEvent = 0; nEvent&lt; events; nEvent++)&#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); KeyedMessage&lt;String,String&gt; data = new KeyedMessage&lt;String, String&gt;(TOPIC,String.valueOf(nEvent),"Test message from java program " + sdf.format(new Date())); Thread.sleep(3000); producer.send(data); &#125; producer.close(); &#125;&#125; 2.2.2 创建订阅者订阅消息下面的代码会绑定到虚拟机长的kafka服务，当发布者发布消息时，订阅者会不断地打印发布者发布的消息： 12345678910111213141516171819202122232425public class MyConsumer &#123; private final static String TOPIC = "page_visits"; public static void main(String[] args) &#123; Properties properties = new Properties(); properties.put("bootstrap.servers","192.168.61.131:9092"); properties.put("enable.auto.commit", "true"); properties.put("group.id", "test"); properties.put("auto.commit.interval.ms", "1000"); properties.put("session.timeout.ms", "30000"); properties.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); properties.put("value.deserializer","org.apache.kafka.common.serialization.StringDeserializer"); KafkaConsumer&lt;String,String&gt; consumer = new KafkaConsumer&lt;String, String&gt;(properties); consumer.subscribe(Arrays.asList(TOPIC)); System.out.println("Subscribe to topic "+TOPIC); while (true)&#123; ConsumerRecords&lt;String,String&gt; consumerRecords = consumer.poll(100); for(ConsumerRecord&lt;String,String&gt; record: consumerRecords)&#123; System.out.printf("offset = %d,key = %s,value = %s\n",record.offset(),record.key(),record.value()); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清醒思考的艺术]]></title>
    <url>%2F2017%2F01%2F11%2Fart-of-thinking-clearly%2F</url>
    <content type="text"><![CDATA[大学的时候读过的一本书，当年排行德国非小说类的第一名，现在又抽空读了一遍，感觉获益颇多，每一篇都很简短，用很小的生活中的例子来解释看似很平常的一些思维谬误，这本书有个很好玩的副标题你最好让别人去犯的52个思维错误，能感受到作者的诙谐和幽默。作者在前言里就说了，生活中的思维错误是不可能避免的，能够意识到并且尽量在生活中少犯就好了，让我说其实更像是程序的bug,是无法避免的，在编程（思考）的时候多加注意就好了。 一、幸存偏误幸存偏误指的是，在生活中更容易看到成功，看不到失败，所以会过高的估计自己成功的希望。最常见的例子 每个成功的人都很努力，所以努力的人都能成功。 这种就是典型的只看到了成功的人而忽视了那些失败的人。所以作者在文章中提醒我们要常常逛逛墓地，看看那些失败者的案例，能够让我们能加清醒的思考。 二、游泳运动员错觉 三、纠缠沉默成本]]></content>
      <categories>
        <category>杂文其他</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的互斥锁和读写锁]]></title>
    <url>%2F2016%2F11%2F26%2Flock-in-java%2F</url>
    <content type="text"><![CDATA[在JDK5之前，访问共享对象的时候使用的机制只有synchronized和volatile ，JDK5的并发包里提供了一种新的更加高级的机制：互斥锁ReentrantLock，显式锁是为了弥补内置锁的方法而开发的，两者是互补的关系，显式锁并不能代替内置锁。ReentrantLock实现了一种标准的互斥锁，亦即每次最多有一个线程能够持有ReentrantLock Lock接口&amp;ReentrantLock简介concurrent包中的Lock类定义了一组抽象的加锁操作，如下代码所示，与synchronized不同的是，Lock提供了一种无条件、可轮询、定时、可中断的锁获取操作，所有的加锁和解锁操作都是显示的ReentrantLock实现了Lock接口，提供了与synchronized相同的互斥性以及内存可见性。与synchronized一样，ReentrantLock提供了可重入（即可以被单个线程多次获取）的加锁语义。 12345678public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; ReentrantLock的使用方法： 12345678Lock lock = new ReentrantLock();...lock.lock();try&#123;&#125; finally&#123; lock.unlock();&#125; 在使用显示锁的时候一定要在finally块中释放锁，否则如果代码中一旦出现异常，那么可能这个锁永远都无法释放就会造成某个对象的状态不一致，如果是账户余额或者别的重要的信息可能就会出现很严重的事故。 与内置锁的区别可轮询及定时的锁在内置锁中，一旦出现死锁，唯一的办法就是重启服务，ReentrantLock使用tryLock()方法来实现可轮询的或者定时的锁，如果一次不能获得全部的锁，那么通过可定时或者轮询的锁可以重新获得控制权，它会释放已经获得的锁然后重新获取所有的锁，如果在指定的时间内没有获取到所有的锁，那么就返回失败。如下例子，通过tryLock()来避免锁顺序死锁 1234567891011121314151617181920212223242526272829303132public boolean transferMoney(Account fromAcc,Account toAcc,Amount amount,long timeout,TimeUnit timeUnit)&#123; long fixeDelay = getFixDelayNanos(timeout,timeUnit); //固定的时间 long ranMod = getRandomDelayNanos(timeout,timeUnit); //随机的时间 long stopTime = System.nanoTime() + timeUnit.toNanos(timeout); while(true)&#123; if(fromAcc.lock.tryLock())&#123; try&#123; if(toAcc.lock.tryLock())&#123; try&#123; if(fromAcc.getBalance().compareTo(amount)&lt;0)&#123; throw new InsufficientFundsException(); &#125;else&#123; fromAcc.debit(amount); to.credit(amount); return true; &#125; &#125;finally&#123; toAcc.lock.unlock(); &#125; &#125; &#125;finally&#123; fromAcc.lock.unklock(); &#125; &#125; if(System.nanoTime()&lt;stopTime) return false; NANOSECONDS.sleep(fixeDelay+rnd.nextLong()%ranMod) &#125;&#125; 另一种方式是使用定时锁，如果在指定的时间内无法获取到锁的话那么将操作失败 可中断的锁获取操作使用Lock接口中的lockInterruptibly方法能够在获得锁的同时保持对中断的响应。 123456789101112public boolean sendSharedLine(String message) throw InterruptedException&#123; lock.lockInterruptibly(); try&#123; return cancellableSendOnSharedLine(message); &#125;finally&#123; lock.unlock(); &#125;&#125;private boolean cancellableSendOnSharedLine(String message) throw InterruptedException&#123; ...&#125; 非块结构的加锁synchronized锁的获取和释放的操作都是基于代码块的，虽然这样能够简化代码的编写，降低编码错误的可能性，但是有的时候可能需要更加灵活的加锁规则。降低锁的力度可以提高代码的伸缩性, 在某些情况下，可以将锁分解成对一组独立对象上的锁的的分解，这种技术被称为锁分段，在ConcurrentHashMap中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16， 一种第N个散列桶由第N mod 16个锁来保护。如果散列函数合理分布，这样锁的请求就减少到了原来的1/16。正是由于锁分段技术，ConcurrentHashMap能够支持多大16个并发的写入器，当然如果并发量足够大的话可以将默认的锁分段数量超过默认的16个。下面的代码块就是ConcurrentHashMap的锁分段的代码，其中能看到Segment是继承与ReentrantLock的，本质上是一把互斥锁。 12345static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; private static final long serialVersionUID = 2249069246763182397L; final float loadFactor; Segment(float lf) &#123; this.loadFactor = lf; &#125;&#125; 公平锁与非公平锁ReentrantLock的构造函数如下，提供了两种公平性的锁，一种是公平锁，一种是非公平的锁（默认） 1234567public ReentrantLock() &#123; sync = new NonfairSync();&#125;public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 在公平锁上，线程按照发出请求的顺序来获得锁，而当线程请求非公平锁时，如果刚好该锁的状态变为可用的话那么久允许这个线程先于队列其他线程获得锁。 公平锁与非公平锁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Sync object for fair locks */ static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; &#125; /** * Sync object for non-fair locks */static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 由代码可以看到公平锁和非公平都是继承于Sync的而Sync是继承与抽象的AQS（AbstractQueuedSynchronizer）的，AQS是java中锁的抽象类，包含了锁的许多公共方法，是互斥锁(例如，ReentrantLock)和共享锁(例如，Semaphore)的公共父类。可以看到公平锁和非公平锁的不同点在于tryAcquire()方法即获取锁的方式不同。 在大多数情况下，非公平锁的性能要高于公平锁的性能。主要原因是在恢复一个被挂起的线程与线程真正运行之间有很大的延迟。假如现在线程A持有一个锁，线程B请求这个锁，由于A持有这个锁，所以B挂起，当A释放锁的时候B被唤醒，再次尝试获取这个锁，如果在同时有C也请求这个锁，那么有很大可能C会在B完全唤醒前获取这个锁使用以及使用这个锁，当B获得锁的时候，C已经使用完毕并释放锁了，所以吞吐量会有所提高。但是当请求锁的平均时间较长的时候应该使用公平锁。 读写锁 ReadWriteLock TODO]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在intellij idea中使用Jrebel]]></title>
    <url>%2F2016%2F11%2F24%2Fuse-jrebel-intellij%2F</url>
    <content type="text"><![CDATA[Jrebel是一个优秀的热部署的插件，虽然intellj中也支持热部署修改class文件后自动更新字节码文件，但是，有时候还是会不起作用，Jrebel这款插件可以支持真正的热部署，以前用过破解版的但是很快就提示licence过期非法，在网上也找不到破解的方法=。=，本来想支持正版的，但是高大$475 每年的价格不是个人能承受的，这本来就是给企业授权用的，其实jrebel的的个人授权是有免费渠道的。可以登陆https://my.jrebel.com/自己注册，然后获得个人授权。 获取个人授权使用twitter或者facebook登陆或自己使用邮箱注册使用twitter或者facebook登陆得使用vpn，如果自己注册的话点击 https://my.jrebel.com/register进入注册 获取activation Code然后激活切换到Install and Activate 选项卡复制出 activation Code 在intellij安装&amp;使用Jrebel 目前我使用的Intellij版本是 2016.3 &gt;IntelliJ IDEA 2016.3 Build #IU-163.7743.44, built on November 18, 2016 Jrebel是最新版的7.0 点击 ctrl+alt+s呼出设置界面，点击 plugins-&gt;browser repositories 然后搜索jrebel就有新版本的jrebel可以下载，如果速度过慢记得挂VPN或者SS，或者自己到jetbrains官网下载最新的插件, Jrebel插件地址 配置Jrebel 安装完jrebel插件后 在设置界面的jrebel子选项中激活Jrebel,激活成功后 使用Jrebel启动项目在使用Jrebel 6.0的时候还需要配置vmoption 升级7.0后可以直接用了不用在配置vmoption了，点击小火箭图标开始运行项目，或者debug图标debug项目]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jrebel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Btrace来跟踪调试代码]]></title>
    <url>%2F2016%2F09%2F10%2Fuse-btrace-to-trace-java-program%2F</url>
    <content type="text"><![CDATA[有的时候在写程序的时候可能有些地方的日志没有照顾到，产生了bug，如果到了线上环境，有时候不得不停掉服务重新来加入日志来查看产生bug的地方，这个时候Btrace就派的上用场了，在VisualVM中可以很方便的调试目标程序，而对原有项目没有影响，当然也可以不用VisualVM而使用命令行来实现这个功能。Btrace是一个开源项目，项目托管在github上 使用VisualVM的Btrace插件最为方便，下面就写个小例子来熟悉一下 准备工作1.在visualvm官网下载visualVM可视化工具2.依次点击visualVM菜单栏的Tool-&gt;plugins打开插件窗口，选择 Btrace workBench 然后一路 next安装 目标程序 准备了一个简单的小程序：从键盘接收两个数字然后计算两个数字之和，主要目的是方便下一步用Btrace来调试打印出方法的参数的值，以及堆栈信息 123456789101112131415161718192021222324package org.xuan.trace;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;/** * Created by Xuan on 2016/9/10. */public class BTraceTest &#123; public int add(int a ,int b)&#123; return a+b; &#125; public static void main(String[] args) throws IOException &#123; BTraceTest traceTest= new BTraceTest(); BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); for (int i = 0; i &lt; 10; i++) &#123; reader.readLine(); int a = (int)Math.round(Math.random()*1000); int b = (int)Math.round(Math.random()*1000); System.out.println(traceTest.add(a,b)); &#125; &#125;&#125; 跟踪程序运行第二步中的小程序，在VisualVM中选中这个虚拟机进程，然后右键Trace application进入到Btrace选项卡在文本框中输入调试的代码： 123456789101112131415/* BTrace Script Template */import com.sun.btrace.annotations.*;import static com.sun.btrace.BTraceUtils.*;@BTracepublic class TracingScript &#123; @OnMethod(clazz="org.xuan.trace.BTraceTest",method="add",location=@Location(Kind.RETURN)) public static void func(@Self org.xuan.trace.BTraceTest instance,int a,int b,@Return int result)&#123; println("打印堆栈:"); jstack(); println(strcat("方法参数A：",str(a))); println(strcat("方法参数B：",str(b))); println(strcat("方法返回C：",str(result))); &#125;&#125; 点击run按钮，如果调试代码没错的话,控制台会输出编译通过的信息 123456* Starting BTrace task** Compiling the BTrace script ...*** Compiled** Instrumenting 1 classes ...*** Done** BTrace up&amp;running 然后在程序的控制台输入一个字符，程序会给出两个参数以及方法的返回值 123456打印堆栈:org.xuan.trace.BTraceTest.add(BTraceTest.java:12)org.xuan.trace.BTraceTest.main(Unknown Source)方法参数A：628方法参数B：461方法参数C：1089]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java List实现group by]]></title>
    <url>%2F2016%2F08%2F22%2Flist-group-by-guava%2F</url>
    <content type="text"><![CDATA[一般情况下我们可能很熟悉在数据库中使用group by来分组一些数据，但是如果数据来源不是数据库的话可能就需要通过在代码中实现group by了 例子：比如有一组书Book的集合,我们要按照书的类型(type)分组 123456789101112package org.xuan;import lombok.AllArgsConstructor;import lombok.Data;@Data@AllArgsConstructorpublic class Book &#123; private String name; private String type; private double price;&#125; 增加几本书到list 123456789List &lt;Book&gt; bookList =Arrays.asList( new Book("java programming","java",123.1D), new Book("java in concurrency","java",123.2D), new Book("c++ primary","c++",123.3D), new Book("groovy in action","groovy",123.4D), new Book("effective java","java",123.5D), new Book("jvm in practice","java",123.6D), new Book("scala in action","scala",123.7D) ); 使用传统的java来实现group by123456789101112Map&lt;String,List&lt;Book&gt;&gt; bookMapOld = Maps.newLinkedHashMap();for (Iterator&lt;Book&gt; iterator = bookList.iterator(); iterator.hasNext(); ) &#123; Book book = iterator.next(); String type = book.getType(); if(bookMapOld.containsKey(type))&#123; bookMapOld.get(type).add(book); &#125;else&#123; List&lt;Book&gt; bookList2 = Lists.newLinkedList(); bookList1.add(book); bookMapOld.put(type,bookList1); &#125;&#125; 使用guava来的multiMap来实现group by12345Multimaps.asMap(Multimaps.index(bookList, new Function&lt;Book, String&gt;() &#123; public String apply(Book input) &#123; return input.getType(); &#125; &#125;)); 使用java 8来实现group by1Map&lt;String,List&lt;Book&gt;&gt;bookMap = bookList1.stream().collect(Collectors.groupingBy(b-&gt;b.getType(),Collectors.mapping((Book b)-&gt;b,Collectors.toList()))); 使用groovy来实现group bygroovy 使用closure来实现groovy by 1Map bookMap = bookList1.groupBy&#123;it.getType()&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom-新一代跨平台开源编辑器]]></title>
    <url>%2F2016%2F07%2F19%2Fuse-atom%2F</url>
    <content type="text"><![CDATA[Atom是一款新一代的编辑器，它的年龄并不大，但是确足够优秀，基于electron构建的跨平台开源编辑器。Github地址：https://github.com/atom/atomatom的开发语言主要是coffeescript与javascript，基于Chromium和nodejs开发，使用包管理系统（apm），想要的功能都可以通过安装package来解决。 官网上的介绍： Atom is a text editor that’s modern, approachable, yet hackable to the core—a tool you can customize to do anything but also use productively without ever touching a config file. 从介绍上来看，atom是一款现代的，易上手的而且足够hackable，官网上的视频介绍更加有趣，上个世纪的一家人不管男女老少都在使用atom编辑器，并且对atom赞不绝口。使用atom写ruby代码与javascript代码是非常高效的，内置了一些常用的package,比如Markdown预览，自带对git的支持等。通过apm可以轻松的安装package，安装好atom-script之后就可以使用ctrl+shift+B快速的执行ruby代码了。]]></content>
      <categories>
        <category>atom</category>
      </categories>
      <tags>
        <tag>atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO创建步骤]]></title>
    <url>%2F2016%2F07%2F18%2Fjava-nio-start%2F</url>
    <content type="text"><![CDATA[NIO创建过程一、打开ServerSocketChannel,用于监听客户端的连接 1ServerSocketChannel acceptSvr = ServerSocketChannel.open(); 二、绑定监听端口，设置连接为非阻塞模式 12acceptSvr.socket().bind(new InetSocketAddress(InetAddress.getByName("IP"),port));accptSvr.configureBlocking(false); 三、创建Reactor线程，创建多路复用器并启动线程 12Selector selector = Selector.open();new Thread(new ReactorTask()).start(); 四、将ServerSocketChannel 注册到Reactor线程的多路多路复用器Selector上，监听ACCEPT事件 1SelectionKey key = acceptorSvr.register(selector,SelectionKey.OP_ACCEPT,ioHandler); 五、多路复用器在线程run方法中无限循环体内轮询准备就绪的Key 123456int num = seletor.select();Set selectedKeys = selector.selectedKeys();while(it.hasNext())&#123; SelectionKey key = (SelectionKey)it.next(); //处理IO事件&#125; 六、多路复用器监听到新的客户端接入，处理新的接入请求，完成TCP三次握手，简历物理链路 1SocketChannel channel = svrChannel.accpet(); 七、设置客户端链路为非阻塞模式 12channel.configureBlocking(flase);channel.socket().setReuseAddress(true); 八、将新接入的客户端连接注册到Reactor线程的多路复用器上，监听读操作，用来读取客户端发送的网络消息 1SelectionKey key = soccketChannel.register(selector,SelectionKey.OP_READ,ioHandler); 九、异步读取客户端请求消息到缓冲区 1int readNumber = channel.read(reaceivedBuffer); 十、对ByteBuffer进行编解码，如果有半包消息指针reset，继续读取后续保温，将解码成功的消息封装成task，投递到业务线程池中，进行业务逻辑编排。 123456789101112131415161718192021Object message = null;while(buffer.hasRemain())&#123; byteBuffer.mark(); Object message = decode(byteBuffer); if(message == null)&#123; byteBuffer.reset(); break; &#125; messageList.add(message); if(!byteBuffer.hasRemain())&#123; byteBuffer,clear(); &#125;else&#123; byteBuffer.compact(); &#125; if(messageList != null &amp; !messageList.isEmpty)&#123; for(Object messageE:messageList)&#123; handlerTask(messageE); &#125; &#125;&#125; 十一、将POJO对象encode 成ByteBuffer ,调用SocketChannel的异步write接口，将消息异步发送给客户端。 1socketChannel.write(buffer);]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jekyll共存python2和python3]]></title>
    <url>%2F2016%2F06%2F13%2Fuse-jekyll-with-python2-3%2F</url>
    <content type="text"><![CDATA[jekyll运行环境 windows 10 pro jekyll 3.1.2 ruby 2.2.1p85 python 2.7 安装完python3时，配置完python3的环境变量之后，运行jekyll时报Liquid Exception: Failed to get header错： 解决办法很简单： 将环境变量中的python3替换为python2即可。 将 12C:\python3.0\C:\python3.0\Script\ 换回 12C:\python2.7\C:\python2.7\Script\]]></content>
      <categories>
        <category>jekyll</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工程师（后端）技能树]]></title>
    <url>%2F2016%2F06%2F02%2Fjava-skill-tree%2F</url>
    <content type="text"><![CDATA[我的Java技能树点亮之路 编程思想脱离于语言之上的一些不变的知识 设计模式，重构，Clean Code ，代码大全，Unix编程艺术 算法导论什么的就算了，但是至少得学会实现《数据结构》上的集中最基本的数据结构，java实现 理解 SOA面向服务架构 工具加成让自己的开发工具从小刀变成 Linux &amp;shell &amp;vim Ngix 工具类 google guava, apache-commons 构建工具maven,gradle Web容器 tomcat 版本控制git java8新特性 mysql&amp;mariadb 数据库进阶，慢查询，数据库引擎，索引 熟悉Http，《图解HTTP》 了解使用noSql，mongodb Java进阶并发编程 熟悉NIO&amp;OIO 熟悉一个NIO框架，我选Netty 熟悉JDK java.util.concurrent包的类，BlockQueue,CocurrentHashMap,Semaphore等 再读一遍《Java并发编程》 深入理解Java内存模型 JVM相关 熟悉GC的原理 JVM相关工具使用以及调优 读完《深入Java虚拟机》,并实践 ClassLoader相关深入理解 动态代理，Cglib使用一些框架 分布式缓存memcached 消息队列ActiveMq实现原理以及使用&amp;JMS的使用 深入Spring相关，Spring Boot等 RPC框架Dubbo 深入Mybatis,实现原理，缓存使用等云相关 Zookeeper，在linux上部署 Hadoop Hive Java之外 学习一门动态语言：Ruby,体会Ruby元编程 使用Rails实现自己的项目 作为Java开发者，Scala自然不能少 学习开源项目 Apache旗下的， Thrift，Tomcat、Mina等]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型【译】]]></title>
    <url>%2F2016%2F05%2F17%2Fjava-memory-model%2F</url>
    <content type="text"><![CDATA[本文翻译自 Java Memory Model旨在加深自己对Java Memory Model (JMM)的理解。 The Java memory model specifies how the Java virtual machine works with the computer’s memory (RAM).The Java virtual machine is a model of a whole computer so this model naturally includes a memory model - AKA the Java memory model.It is very important to understand the Java memory model if you want to design correctly behaving concurrent programs.The Java memory model specifies how and when different threads can see values written to shared variables by other threads, and how to synchronize access to shared variables when necessary.The original Java memory model was insufficient, so the Java memory model was revised in Java 1.5. This version of the Java memory model is still in use in Java 8. Java内存模型详述了java虚拟机如何与物理机的RAM的一起工作的，java虚拟机是整个计算机的模型，所以这个模型自然包括内存模型，这个模型卡就是Java内存模型。如果你想正确的设计并发程序，知道Java内存模型是非常重要的java内存模型详解了多个不同的线程是何时而又如何写入一个共享的变量的，还有如何同步的访问一个共享变量。原来的Java内存模型是不足的，所以Java内存模型在java 5中重新修订了，这个版本的java内存模型一直在Java8中还在使用。 内部的java内存模型 The Java memory model used internally in the JVM divides memory between thread stacks and the heap. This diagram illustrates the Java memory model from a logic perspective: Java内存模型将JVM的内存按照线程栈和堆进行分割，下面的图表从逻辑的视图展示了Java内存模型：![enter description here][http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png] Each thread running in the Java virtual machine has its own thread stack.The thread stack contains information about what methods the thread has called to reach the current point of execution. I will refer to this as the “call stack”. As the thread executes its code, the call stack changes.The thread stack also contains all local variables for each method being executed (all methods on the call stack). A thread can only access it’s own thread stack.Local variables created by a thread are invisible to all other threads than the thread who created it. Even if two threads are executing the exact same code,the two threads will still create the local variables of that code in each their own thread stack. Thus, each thread has its own version of each local variable.All local variables of primitive types ( boolean, byte, short, char, int, long, float, double) are fully stored on the thread stack and are thus not visible to other threads.One thread may pass a copy of a pritimive variable to another thread, but it cannot share the primitive local variable itself.The heap contains all objects created in your Java application, regardless of what thread created the object. This includes the object versions of the primitive types (e.g. Byte, Integer, Long etc.).It does not matter if an object was created and assigned to a local variable, or created as a member variable of another object, the object is still stored on the heap. 每一个运行在JVM上的线程都有自己的线程栈，线程栈中包含了线程当前执行点的方法的详细信息，我想这个称之为调用栈,当线程执行了代码，调用栈就发生了变化。线程栈中也包含了所有的正在执行方法（所有在在调用栈中的方法）的局部变量，一个线程只能访问自己的线程栈。被线程创建的本地变量对于其他的线程来说是不可见的,即使两个线程执行同样的代码，这两个线程仍然会在自己的线程栈上创本地变量。所有的原始类型（ boolean, byte, short, char, int, long, float, double）的本地变量全部存储在自己的线程栈中对其他线程不可见，一个线程可以传递一个原始类型的变量给其他线程，但是不能和其他线程共享原始类型的变量。堆中包含了你的java程序中的所有的对象，不管是由哪个线程创建的对象，其中包含了原始类型对应的Wrapper类（Byte, Integer, Long etc），不管一个对象是被分配给一个局部变量还是成员变量，这个对象都仍旧保存在堆上。 Here is a diagram illustrating the call stack and local variables stored on the thread stacks, and objects stored on the heap: 下面是一个图表说明了在线程栈中保存的调用栈，局部变量和在堆中保存的所有对象。![enter description here]http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png] A local variable may be of a primitive type, in which case it is totally kept on the thread stack.A local variable may also be a reference to an object. In that case the reference (the local variable) is stored on the thread stack, but the object itself if stored on the heap.An object may contain methods and these methods may contain local variables. These local variables are also stored on the thread stack, even if the object the method belongs to is stored on the heap.An object’s member variables are stored on the heap along with the object itself. That is true both when the member variable is of a primitive type, and if it is a reference to an object.Static class variables are also stored on the heap along with the class definition.Objects on the heap can be accessed by all threads that have a reference to the object. When a thread has access to an object, it can also get access to that object’s member variables.If two threads call a method on the same object at the same time, they will both have access to the object’s member variables, but each thread will have its own copy of the local variables. 一个局部变量可能是原始类型的，这种情况下，它将完全保存在线程栈上一个局部变量也可能引用一个对象，这个中情况下引用（该局部变量）将会被存储在线程栈中，而被引用的对象将会被存储在堆上。一个对象可能包含多个方法，而这些方法也可能包含局部变量，这些局部变量也将会保存在线程栈上，即使该方法所属的对象是存在堆上的。一个对象的成员变量和对象本身一起被存放在堆上，不管成员变量是基本数据类型的还是引用数据类型的。静态成员变量将会和类定义一起被保存在堆上。在堆上保存的对象可以被所有和这个对象有引用关系的线程访问，当一个线程有权访问一个对象，那么这个线程也能够访问这个对象的成员变量。当两个线程同时调用同一个对象的某个方法，他们将同时拥有该对对象的成员变量的访问权，但是每个线程将会有一份局部变量的副本。 Here is a diagram illustrating the points above: 下图说明上述观点：![enter description here][http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png] Two threads have a set of local variables. One of the local variables (Local Variable 2) point to a shared object on the heap (Object 3).The two threads each have a different reference to the same object.Their references are local variables and are thus stored in eachthread’s thread stack (on each). The two different references point to the same object on the heap, though.Notice how the shared object (Object 3) has a reference to Object 2 and Object 4 as member variables (illustrated by the arrows from Object 3 to Object 2 and Object 4).Via these member variable references in Object 3 the two threads can access Object 2 and Object 4.The diagram also shows a local variable which point to two different objects on the heap. In this case the references point to two different objects (Object 1 and Object 5), not the same object.In theory both threads could access both Object 1 and Object 5, 但是上图中的两个线程都只有两个对象中的一个的引用。if both threads had references to both objects. But in the diagram above each thread only has a reference to one of the two objects. 两个线程都各自一个局部变量的集合，其中的一个局部变量（Local Variable 2）只想了堆上的一个共享对象（Object 3），两个线程对同一个对象有不同的引用。他们的引用都是局部变量并且都被存在自己的线程栈上，尽管两个引用只想堆上的同一个对象。注意到共享对象（Object 3）对 Object 2 和 Object 4 有作为成员变量的引用关系（Object 3指向Object 2和Object 4的箭头）。通过在Object 3 中引用成员变量，这两个线程可以访问Object 2和Object 4 上图也展示了一个指向堆上不同对象的局部变量，这种情况下引用指向了对上的不同对象（Object 1 和Object 5）而不是同一个对象，理论上讲，如果两个各对象都有两个对象的引用的话是可以访问Object 1和Object 5 So, what kind of Java code could lead to the above memory graph? Well, code as simple as the code below: 所以，什么样的Java 代码可以解释上面的内存图，代码简单如下： 1234567891011121314151617181920212223public class MyRunnable implements Runnable() &#123; public void run() &#123; methodOne(); &#125; public void methodOne() &#123; int localVariable1 = 45; MySharedObject localVariable2 = MySharedObject.sharedInstance; //... do more with local variables. methodTwo(); &#125; public void methodTwo() &#123; Integer localVariable1 = new Integer(99); //... do more with local variable. &#125;&#125; 12345678910111213141516public class MySharedObject &#123; //static variable pointing to instance of MySharedObject public static final MySharedObject sharedInstance = new MySharedObject(); //member variables pointing to two objects on the heap public Integer object2 = new Integer(22); public Integer object4 = new Integer(44); public long member1 = 12345; public long member1 = 67890;&#125; If two threads were executing the run() method then the diagram shown earlier would be the outcome. The run() method calls methodOne() and methodOne() calls methodTwo().methodOne() declares a primitive local variable (localVariable1 of type int) and an local variable which is an object reference (localVariable2).Each thread executing methodOne() will create its own copy of localVariable1 and localVariable2 on their respective thread stacks.The localVariable1 variables will be completely separated from each other, only living on each thread’s thread stack.One thread cannot see what changes another thread makes to its copy of localVariable1. 如果两个方法同时执行 run()方法，run()方法调用methodOne()然后 methodOne()调用 methodTwo()methodOne() 声明了一个基本数据类型的局部变量（int类型 localVariable1）和一个引用数据类型的局部变量（localVariable2）每一个线程在执行methodOne()时将会创建 localVariable1 和localVariable2的副本在各自的线程栈。局部变量 localVariable1 将会和其他的变量分割开来，仅仅存活在自己线程的线程栈中。线程不能够看到其他线程对localVariable1变量副本做出的改变。 Each thread executing methodOne() will also create their own copy of localVariable2.However, the two different copies of localVariable2 both end up pointing to the same object on the heap.The code sets localVariable2 to point to an object referenced by a static variable.There is only one copy of a static variable and this copy is stored on the heap.Thus, both of the two copies of localVariable2 end up pointing to the same instance of MySharedObject which the static variable points to.The MySharedObject instance is also stored on the heap. It corresponds to Object 3 in the diagram above.Notice how the MySharedObject class contains two member variables too. The member variables themselves are stored on the heap along with the object.The two member variables point to two other Integer objects. These Integer objects correspond to Object 2 and Object 4 in the diagram above.Notice also how methodTwo() creates a local variable named localVariable1. This local variable is an object reference to an Integer object.The localVariable1 reference will be stored in one copy per thread executing methodTwo().The method sets the localVariable1 reference to point to a new Integer instance.The two Integer objects instantiated will be stored on the heap, but since the method creates a new Integer object every time the method is executed, two threads executing this method will create separate Integer instances.The Integer objects created inside methodTwo() correspond to Object 1 and Object 5 in the diagram above.Notice also the two member variables in the class MySharedObject of type long which is a primitive type.Since these variables are member variables, they are still stored on the heap along with the object. Only local variables are stored on the thread stack. 每个线程执行methodOne()时也将会创建它们各自的localVariable2拷贝。然而，两个localVariable2的不同拷贝都指向堆上的同一个对象。 代码中通过一个静态变量设置localVariable2指向一个对象引用。 仅存在一个静态变量的一份拷贝，这份拷贝存放在堆上。 因此，localVariable2的两份拷贝都指向由MySharedObject指向的静态变量的同一个实例。 MySharedObject实例也存放在堆上。它对应于上图中的Object3。注意，MySharedObject类也包含两个成员变量，这些成员变量随着这个对象存放在堆上。这两个成员变量指向另外两个Integer对象。这些Integer对象对应于上图中的Object2和Object4.注意，methodTwo()创建一个名为localVariable的本地变量。这个成员变量是一个指向一个Integer对象的对象引用。这个方法设置localVariable1引用指向一个新的Integer实例。在执行methodTwo方法时，localVariable1引用将会在每个线程中存放一份拷贝。这两个Integer对象实例化将会被存储堆上，但是每次执行这个方法时，这个方法都会创建一个新的Integer对象，两个线程执行这个方法将会创建两个不同的Integer实例。methodTwo()方法创建的Integer对象对应于上图中的Object1和Object5。注意，MySharedObject类中的两个long类型的成员变量是原始类型的。因为，这些变量是成员变量，所以它们任然随着该对象存放在堆上，仅有本地变量存放在线程栈上。 硬件的内存架构（TODO）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cURL命令的使用]]></title>
    <url>%2F2016%2F05%2F08%2Fhow-use-curl%2F</url>
    <content type="text"><![CDATA[Linux curl命令的使用 参考官方文档 https://curl.haxx.se/docs/manpage.html 一、什么是cURL wikipedia中的解释如下： cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。 cURL支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。 简单的说，cURL就是把发出请求然后得到响应并把响应数据显示到标准输出上的一个命令行工具。 语法： curl [option] [URL] 二、cURL的用法1. 保存curl的结果到文件curl -o [filename] [URL] 比如要保存 http://zeusjava.com 到blog.html中，可以使用 curl -o blog.html http://zeusjava.com 当然，也可以直接用 curl http://zeusjava.com &gt;blog.html 1$ curl -o blog.html http://zeusjava.com 使用 -o 也可以用于下载文件 curl -o android-studio-2.0.exe https://dl.google.com/dl/android/studio/install/2.0.0.20/android-studio-bundle-143.2739321-windows.exe 使用 -O可以将下载的文件名自动命名为服务器端文件的名字 curl -O https://dl.google.com/dl/android/studio/install/2.0.0.20/android-studio-bundle-143.2739321-windows.exe 2.显示http response的Header信息curl -i [URL] 比如 curl -i http://zeusjava.com 服务器返回的Header信息如下： 12345678910111213141516171819HTTP/1.1 200 OKServer: GitHub.comContent-Type: text/html; charset=utf-8Last-Modified: Thu, 14 Apr 2016 05:39:44 GMTAccess-Control-Allow-Origin: *Expires: Mon, 02 May 2016 22:38:46 GMTCache-Control: max-age=600X-GitHub-Request-Id: 17EB2B23:6096:A5D8C82:5727D49CContent-Length: 16009Accept-Ranges: bytesDate: Sat, 07 May 2016 10:25:24 GMTVia: 1.1 varnishAge: 0Connection: keep-aliveX-Served-By: cache-ams4129-AMSX-Cache: HITX-Cache-Hits: 1Vary: Accept-EncodingX-Fastly-Request-ID: cd84d46856e9a80b4a283db2225e8caeb0d439b0 由于使用过的是Github Pages 所以Server是Github.com 3.显示Http request和 response的Header信息curl -v [URL] -v选项可以向标准输出中打印和Server的通信过程的信息，包括 http request和http response的信息下面是和zeusjava.com的通信过程的头部信息： 123456789101112131415161718192021222324252627* Rebuilt URL to: http://www.zhihu.com/* Trying 58.216.25.33...* Connected to www.zhihu.com (58.216.25.33) port 80 (#0)&gt; GET / HTTP/1.1&gt; Host: www.zhihu.com&gt; User-Agent: curl/7.48.0&gt; Accept: */*&gt; &lt; HTTP/1.1 200 OK&lt; Server: ZWS&lt; Connection: keep-alive&lt; Date: Mon, 13 Jun 2016 06:28:32 GMT&lt; Cache-Control: no-store&lt; Content-Type: text/html; charset=UTF-8&lt; Content-Length: 8440&lt; X-Za-Response-Id: 1be55a9577484a62ae8289e23216dfdb&lt; Content-Security-Policy: default-src *; img-src * data:; frame-src &apos;self&apos; *.zhihu.com getpocket.com note.youdao.com; script-src &apos;self&apos; *.zhihu.com *.google-analytics.com zhstatic.zhihu.com res.wx.qq.com &apos;unsafe-eval&apos;; style-src &apos;self&apos; *.zhihu.com &apos;unsafe-inline&apos;&lt; Set-Cookie: q_c1=3af89a60e8454cad977358c33bff9823|1465799312000|1465799312000; Domain=zhihu.com; expires=Thu, 13 Jun 2019 06:28:32 GMT; Path=/&lt; Set-Cookie: _xsrf=ed72c7326f8de881578826312673cebe; Path=/&lt; Set-Cookie: l_cap_id=&quot;OTlmZjM4OGQ4YzEyNDkwNmJjMzQxM2NiZThlOGY3MDI=|1465799312|380fb662f09187c07ae84e38dc694197feae1f09&quot;; Domain=zhihu.com; expires=Wed, 13 Jul 2016 06:28:32 GMT; Path=/&lt; Set-Cookie: cap_id=&quot;NDZhN2I5ZmM0ZjZlNGQxOWI4MDhkZTg0ZTZlMTU1ZDA=|1465799312|fc2935c8732a53b5216bbffebbceed1cf179f5ab&quot;; Domain=zhihu.com; expires=Wed, 13 Jul 2016 06:28:32 GMT; Path=/&lt; Set-Cookie: n_c=1; Domain=zhihu.com; Path=/&lt; Pragma: no-cache&lt; X-Frame-Options: DENY&lt; X-Req-ID: 43CAD096575E5290&lt; Vary: Accept-Encoding&lt; 4. HTTP动词Http的动词有，GET,POST,PUT,DELETE等 curl -X [动词] [URL] curl默认的动作为 GET 3.1 FORM GET请求curl [-X GET] zeusjava.com/articles?article_id=1 3.2 FORM POST请求curl -X POST --data[-urlencode] "article_id=1" zeusjava.com 如果需要对表单参数进行编码的话，在–data后再加上-urlencode选项 5. 使用Cookiescurl --cookie "key=value" [URL] cookie是客户端保存的服务端的一些信息,形式为key-value键值对，可以从Server的response的Set-Cookie中获得 使用 -c 选项，可以保存服务器的cookie到本地的文件中 curl -c [cookies file] [URL] 比如我保存 知乎的cookie到本地的cookies中 curl -c cookies.txt http://www.zhihu.com 得到的cookies.txt如下： 12345678910# Netscape HTTP Cookie File# http://curl.haxx.se/docs/http-cookies.html# This file was generated by libcurl! Edit at your own risk..zhihu.com TRUE / FALSE 0 l_n_c 1.zhihu.com TRUE / FALSE 1557273691 q_c1 5130907cc98041298bb4a42fafa2fe5d|1462665691000|1462665691000www.zhihu.com FALSE / FALSE 0 _xsrf f3e5105c5196dffc93c5eefcbb1d2b55.zhihu.com TRUE / FALSE 1465257691 cap_id &quot;ZWQ2ZDIyNmQ2NjZjNDNjYzg1Y2QyZjE3ZjU5ZGM1YWY=|1462665691|258e372f45b5610e483a25bfa3dde1debd56ca08&quot;.zhihu.com TRUE / FALSE 1465257691 l_cap_id &quot;NjMxYTliZGVkOWZlNDBmZDhjY2M2M2VjY2Y1MDQ0YTI=|1462665691|878a16bb3c5376f14a0d837c19db994c66b6b668&quot;.zhihu.com TRUE / FALSE 0 n_c 1 使用 -b选项，将本地的cookies文件发送至服务器端 curl -b cookies.txt http://www.zhihu.com 6.使用User-Agent User Agent：字面意思就是用户代理，可以简单理解为访问设备的一种标识（这个标识指所代表的平台（黑莓、iPhone、Windows等）、浏览器（Chrome、IE、Safari等）、以及浏览器的版本等等），其实它包含的信息是比较多的。 下面是一个User-Agent的例子: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36 Mozilla声明了一个基于Mozilla的浏览器User-Agent，比如firefox,netscape等,Windows NT 10.0表示操作系统为 Windows 10等 curl -A [User-Agent] [URL] curl --user-agent "[User-Agent]" [URL] 很多网站都会根据浏览器的User-Agent来响应不同的页面风格，叫做响应式设计，比如ipad请求 www.zhihu.com浏览器就会根据ipad的页面尺寸来适配ipad的屏幕大小。 7.文件上传使用curl来模拟表单的文件上传 1234 &lt;form method="POST" enctype='multipart/form-data' action="upload.do"&gt; &lt;input type=file name="headimage"&gt; &lt;input type=submit name ="click" value="点击上传"&gt; &lt;/form&gt; $ curl –form headimage=@localfile –form click=点击上传 [URL] 三、总结当然curl的命令不止这么多，用到哪些在做补充 ==]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC源码探究]]></title>
    <url>%2F2016%2F04%2F06%2Fspring-mvc-source-code%2F</url>
    <content type="text"><![CDATA[作为一名合格的java程序员，要多深入学习一些框架，理解框架的设计的方法，背后的原理，spring mvc框架中使用了很多设计模式，比如策略模式，Spring MVC中大量使用了策略模式，像HandlerMapping接口，HandlerAdapter接口,ViewResolver接口都使用了策略模式，在执行handler和Interceptor拦截器的时候使用了责任链模式，在执行handler的时候会用到适配器模式等等，可以说沉淀了很多前辈的精华，想成为架构师的话，学习源码必不可少，下面就围绕着Spring MVC 的前端控制器DispatcherServlet一步一步的来学习Spring MVC的源码。 1 web.xml中DispatcherServlet的配置web.xml中的Spring MVC的前端控制器DispatcherServlet的配置，所有后端Controller的请求都由这个DispatcherServlet分发。 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;MySpringServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MySpringServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; DispatcherServlet 类等级视图 DispactcherServlet 中的doService()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Exposes the DispatcherServlet-specific request attributes and delegates to &#123;@link #doDispatch&#125; * for the actual dispatching. */ @Override protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; if (logger.isDebugEnabled()) &#123; String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? " resumed" : ""; logger.debug("DispatcherServlet with name '" + getServletName() + "'" + resumed + " processing " + request.getMethod() + " request for [" + getRequestUri(request) + "]"); &#125; // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;String, Object&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith("org.springframework.web.servlet")) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); try &#123; //执行dispatch方法 doDispatch(request, response); &#125; finally &#123; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; return; &#125; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; &#125; doService方法实现了抽象类FrameworkServlet的doService方法，在doService方法中调用了doDispatcher()方法处理分发请求 2.DipatcherServlet的doDispatcher()方法doService方法中将请求委托给doDispatch()方法由doDispatch()来分发相应的请求给各个Handler(Controller),我在每一个关键步骤上标注了注释，下面还有相应的源码解释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * Process the actual dispatching to the handler. * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order. * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters * to find the first that supports the handler class. * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers * themselves to decide which methods are acceptable. * @param request current HTTP request * @param response current HTTP response * @throws Exception in case of any kind of processing failure */protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; //1.检测是否是多媒体请求，比如文件上传，将HttpServletRequest包装为MultipartHttpServletRequest processedRequest = checkMultipart(request); multipartRequestParsed = processedRequest != request; //2.遍历所有的HandlerMapper对象根据请求的URL获得相应的HandlerExecutionChain，其中HandlerMapping是一个 //接口，Spring给出了一个默认的实现配置在DispatcherServlet.properties文件中，如果找不到对应的HandlerMap//per，spring会给出提示 No mapping found for HTTP request with URI... mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; //3.根据当前的request遍历所有的Adapter选择第一个支持的adapter，这里使用了责任链模式 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. //4.处理 last-modified header 判断是否被handler支持 String method = request.getMethod(); boolean isGet = "GET".equals(method); if (isGet || "HEAD".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug("Last-Modified value for [" + getRequestUri(request) + "] is: " + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; //5.执行handler的拦截器的preHandle方法 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; try &#123; // 6.调用真正的handler，处理业务代码 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; &#125; applyDefaultViewName(request, mv); //7.执行handler的拦截器的postHandle方法 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; //8.处理返回结果视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Error err) &#123; triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); return; &#125; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125;&#125; 1. 根据request获得所有的HandlerMapping并匹配一个合适的Handler（Controller）AbstractHandlerMapping实现了HandlerMapping接口 1234567891011121314151617181920212223242526272829303132333435 1：遍历所有intercepter，取指定接口的拦截器bean 2：根据url找到对应的hander 3：封装成chain @Override public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; Object handler = getHandlerInternal(request); if (handler == null) &#123; handler = getDefaultHandler(); &#125; if (handler == null) &#123; return null; &#125; // Bean name or resolved handler? if (handler instanceof String) &#123; String handlerName = (String) handler; handler = getApplicationContext().getBean(handlerName); &#125; return getHandlerExecutionChain(handler, request); &#125; /** protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123; HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ? (HandlerExecutionChain) handler : new HandlerExecutionChain(handler)); chain.addInterceptors(getAdaptedInterceptors()); String lookupPath = this.urlPathHelper.getLookupPathForRequest(request); for (MappedInterceptor mappedInterceptor : this.mappedInterceptors) &#123; if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123; chain.addInterceptor(mappedInterceptor.getInterceptor()); &#125; &#125; return chain; &#125; AbstractUrlHandlerMapping继承了AbstractHandlerMapping重写了getHandlerInternal()抽象方法。这个方法给出了根据请求的URL获得handler的实现方法。 12345678910111213141516171819202122232425262728293031323334353637/** * Look up a handler for the URL path of the given request. * @param request current HTTP request * @return the handler instance, or &#123;@code null&#125; if none found */ @Override protected Object getHandlerInternal(HttpServletRequest request) throws Exception &#123; String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); Object handler = lookupHandler(lookupPath, request); if (handler == null) &#123; // We need to care for the default handler directly, since we need to // expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well. Object rawHandler = null; if ("/".equals(lookupPath)) &#123; rawHandler = getRootHandler(); &#125; if (rawHandler == null) &#123; rawHandler = getDefaultHandler(); &#125; if (rawHandler != null) &#123; // Bean name or resolved handler? if (rawHandler instanceof String) &#123; String handlerName = (String) rawHandler; rawHandler = getApplicationContext().getBean(handlerName); &#125; validateHandler(rawHandler, request); handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null); &#125; &#125; if (handler != null &amp;&amp; logger.isDebugEnabled()) &#123; logger.debug("Mapping [" + lookupPath + "] to " + handler); &#125; else if (handler == null &amp;&amp; logger.isTraceEnabled()) &#123; logger.trace("No handler mapping found for [" + lookupPath + "]"); &#125; return handler; &#125; 2.获得HandlerExecutionChain12345678910111213141516171819/** * Return the HandlerExecutionChain for this request. * &lt;p&gt;Tries all handler mappings in order. * @param request current HTTP request * @return the HandlerExecutionChain, or &#123;@code null&#125; if no handler could be found */ protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; for (HandlerMapping hm : this.handlerMappings) &#123; if (logger.isTraceEnabled()) &#123; logger.trace( "Testing handler map [" + hm + "] in DispatcherServlet with name '" + getServletName() + "'"); &#125; HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; return null; &#125; HandlerExecutionChain是由一系列的Handler和HandlerInterceptor组成的责任链，下面是HandlerExecutionChain中的成员变量 123456789private static final Log logger = LogFactory.getLog(HandlerExecutionChain.class); private final Object handler; private HandlerInterceptor[] interceptors; private List&lt;HandlerInterceptor&gt; interceptorList; private int interceptorIndex = -1; 3.根据相应的handler去获得合适的HandlerAdapterHandlerAdapter 123456789101112131415161718package org.springframework.web.servlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public interface HandlerAdapter &#123; boolean supports(Object handler); ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; long getLastModified(HttpServletRequest request, Object handler);&#125; HandlerAdapter的实现类HttpRequestHandlerAdapter，在DispatcherServlet.properties文件配置的默认实现的其中之一，在HandlerAdapter中执行Handler（Controller）的方法，并且给前端控制器DispatcherServlet返回一个ModelAndView 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * Copyright 2002-2012 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.web.servlet.mvc;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.HttpRequestHandler;import org.springframework.web.servlet.HandlerAdapter;import org.springframework.web.servlet.ModelAndView;/** * Adapter to use the plain &#123;@link org.springframework.web.HttpRequestHandler&#125; * interface with the generic &#123;@link org.springframework.web.servlet.DispatcherServlet&#125;. * Supports handlers that implement the &#123;@link LastModified&#125; interface. */public class HttpRequestHandlerAdapter implements HandlerAdapter &#123; //判断是否适配当前adapter @Override public boolean supports(Object handler) &#123; return (handler instanceof HttpRequestHandler); &#125; @Override public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ((HttpRequestHandler) handler).handleRequest(request, response); return null; &#125; @Override public long getLastModified(HttpServletRequest request, Object handler) &#123; if (handler instanceof LastModified) &#123; return ((LastModified) handler).getLastModified(request); &#125; return -1L; &#125;&#125; HttpRequestHandler接口的实现类ResourceHttpRequestHandler,handleRequest()方法用来处理请求返回结果，数据转化，数据校验，格式化等操作都是在这一步进行。比如自动将Json数据转换为对应的实体等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Processes a resource request. * &lt;p&gt;Checks for the existence of the requested resource in the configured list of locations. * If the resource does not exist, a &#123;@code 404&#125; response will be returned to the client. * If the resource exists, the request will be checked for the presence of the * &#123;@code Last-Modified&#125; header, and its value will be compared against the last-modified * timestamp of the given resource, returning a &#123;@code 304&#125; status code if the * &#123;@code Last-Modified&#125; value is greater. If the resource is newer than the * &#123;@code Last-Modified&#125; value, or the header is not present, the content resource * of the resource will be written to the response with caching headers * set to expire one year in the future. */@Overridepublic void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; checkAndPrepare(request, response, true); // check whether a matching resource exists Resource resource = getResource(request); if (resource == null) &#123; logger.debug("No matching resource found - returning 404"); response.sendError(HttpServletResponse.SC_NOT_FOUND); return; &#125; // check the resource's media type MediaType mediaType = getMediaType(resource); if (mediaType != null) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Determined media type '" + mediaType + "' for " + resource); &#125; &#125; else &#123; if (logger.isDebugEnabled()) &#123; logger.debug("No media type found for " + resource + " - not sending a content-type header"); &#125; &#125; // header phase if (new ServletWebRequest(request, response).checkNotModified(resource.lastModified())) &#123; logger.debug("Resource not modified - returning 304"); return; &#125; setHeaders(response, resource, mediaType); // content phase if (METHOD_HEAD.equals(request.getMethod())) &#123; logger.trace("HEAD request - skipping content"); return; &#125; writeContent(response, resource);&#125; 4.处理返回结果视图处理异常视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Handle the result of handler selection and handler invocation, which is * either a ModelAndView or an Exception to be resolved to a ModelAndView. */ private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug("ModelAndViewDefiningException encountered", exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); //处理异常视图 mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Null ModelAndView returned to DispatcherServlet with name '" + getServletName() + "': assuming HandlerAdapter completed request handling"); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; mappedHandler.triggerAfterCompletion(request, response, null); &#125; &#125; 渲染指定的 ModelAndView 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Render the given ModelAndView. * &lt;p&gt;This is the last stage in handling a request. It may involve resolving the view by name. * @param mv the ModelAndView to render * @param request current HTTP servlet request * @param response current HTTP servlet response * @throws ServletException if view is missing or cannot be resolved * @throws Exception if there's a problem rendering the view */protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Determine locale for request and apply it to the response. Locale locale = this.localeResolver.resolveLocale(request); response.setLocale(locale); View view; if (mv.isReference()) &#123; // We need to resolve the view name. view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException("Could not resolve view with name '" + mv.getViewName() + "' in servlet with name '" + getServletName() + "'"); &#125; &#125; else &#123; // No need to lookup: the ModelAndView object contains the actual View object. view = mv.getView(); if (view == null) &#123; throw new ServletException("ModelAndView [" + mv + "] neither contains a view name nor a " + "View object in servlet with name '" + getServletName() + "'"); &#125; &#125; // Delegate to the View object for rendering. if (logger.isDebugEnabled()) &#123; logger.debug("Rendering view [" + view + "] in DispatcherServlet with name '" + getServletName() + "'"); &#125; try &#123; view.render(mv.getModelInternal(), request, response); &#125; catch (Exception ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Error rendering view [" + view + "] in DispatcherServlet with name '" + getServletName() + "'", ex); &#125; throw ex; &#125;&#125; 3.DispatcherServlet.propertiesDispatcherServlet.properties中配置的一些DispatcherServlet的一些策略模式接口的实现，包括HandlerMapping，HandlerAdapter，ViewResolver等 123456789101112131415161718192021222324# Default implementation classes for DispatcherServlet's strategy interfaces.# Used as fallback when no matching beans are found in the DispatcherServlet context.# Not meant to be customized by application developers.org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolverorg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolverorg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\ org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\ org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapterorg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\ org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\ org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolverorg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslatororg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolverorg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager 4.总结下图是Spring MVC 工作流程的时序图 1. 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获； 2. DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； 3. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(...)方法） 4. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 5. Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象； 6. 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ； 7. ViewResolver 结合Model和View，来渲染视图 8. 将渲染结果返回给客户端。]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合中的Fail-fast和Fail-Safe机制]]></title>
    <url>%2F2016%2F03%2F23%2Fjava-collection-failfast-failsafe%2F</url>
    <content type="text"><![CDATA[1.何为Fail-fast和Fail-Safe机制？java.util包里的Iterator 抛出ConcurrentModificationException异常， 在集合迭代的时候被集合的add方法或者 remove方法调用。fail-fast 指java的集合的一种错误机制，当多个线程对集合修改操作的时候就可能抛出ConcurrentModificationException异常。 java.util.concurrent包里的Iterator 通过迭代一个集合的snapshot 允许并发修改集合，但是在迭代器创建之后可能不反映Collection更新。fail-safe机制意味着多个线程在操作同一个集合的时候，不会出现ConcurrentModificationException异常,但是需要复制集合获得集合的快照，所以性能上开销会比非同步的集合开销要大。 多线程环境下用java.util.concurrent包里的集合替代 java.util包里的集合，比如 CopyOnWriteList=&gt;ArrayList,ConcurrentHashMap=&gt;HashMap etc. 2.JDK中的源码分析下面代码是JDK1.7源码中ArrayList中的ListIterator，当Iterator创建时，当前的计数器modCount 赋值给Iterator对象,注意到modCount是一个 transient类型的成员变量，transient说明了计数器将不被序列化。 protected transient int modCount = 0; modCount用来记录List修改的次数的计数器，每修改一次(添加/删除等操作)，将modCount+1，例如 add()方法： 1234567public void add(int index, E element) &#123; rangeCheckForAdd(index); checkForComodification(); l.add(index+offset, element); this.modCount = l.modCount; size++; &#125; 当Iterator执行相应操作的时候，会先检验两个计数器的值是否相等，如果不相等就抛出ConcurrentModificationException 异常。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; CopyOnWriteArrayList的Iterator，可以看到COWIterator在构造函数初始化的时候把集合中的元素保存了一份快照，所有的操作都在快照上面进行的。CopyOnWriteArrayList的Iterator实现类中，checkForComodification()方法，也没有抛出ConcurrentModificationException异常！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; /** Snapshot of the array */ private final Object[] snapshot; /** Index of element to be returned by subsequent call to next. */ private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125; public boolean hasNext() &#123; return cursor &lt; snapshot.length; &#125; public boolean hasPrevious() &#123; return cursor &gt; 0; &#125; @SuppressWarnings("unchecked") public E next() &#123; if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; &#125; @SuppressWarnings("unchecked") public E previous() &#123; if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor-1; &#125; /** * Not supported. Always throws UnsupportedOperationException. * @throws UnsupportedOperationException always; &lt;tt&gt;remove&lt;/tt&gt; * is not supported by this iterator. */ public void remove() &#123; throw new UnsupportedOperationException(); &#125; /** * Not supported. Always throws UnsupportedOperationException. * @throws UnsupportedOperationException always; &lt;tt&gt;set&lt;/tt&gt; * is not supported by this iterator. */ public void set(E e) &#123; throw new UnsupportedOperationException(); &#125; /** * Not supported. Always throws UnsupportedOperationException. * @throws UnsupportedOperationException always; &lt;tt&gt;add&lt;/tt&gt; * is not supported by this iterator. */ public void add(E e) &#123; throw new UnsupportedOperationException(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Java的NIO]]></title>
    <url>%2F2016%2F02%2F28%2Flearn-java-nio%2F</url>
    <content type="text"><![CDATA[重要的概念 什么是NIO?NIO是从java 1.4 开始引入的一个新的 IO API。 Channel、Buffer、Selector是NIO的核心部分。 IO通过字节流和字符流操作数据，NIO基于通道(Channel)和缓冲区(Buffer)数据 Channel&amp;BufferChannel数据总是由通道到缓冲区（Read），或者由缓冲区到通道（write） 其中Channel的几个实现 FileChannel DatagramChannel SocketChannel ServerSocketChannel 分别对应文件IO/UDP/TCP网络IO. 下面是一个简单的例子实现，从本地文件系统读取数据到Buffer中。 1234567891011121314151617181920212223242526/** * Channel的使用 */ @Test public void fileChannelTest()&#123; try &#123; RandomAccessFile randomAccessFile = new RandomAccessFile("D:/nio.txt","rw"); FileChannel fileChannel = randomAccessFile.getChannel(); ByteBuffer byteBuffer = ByteBuffer.allocate(100); int bytesRead = fileChannel.read(byteBuffer); while (bytesRead != -1)&#123; System.out.println("Read:"+bytesRead); byteBuffer.flip(); while(byteBuffer.hasRemaining())&#123; System.out.print((char)byteBuffer.get()); &#125; byteBuffer.clear(); bytesRead = fileChannel.read(byteBuffer); &#125; randomAccessFile.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; BufferBuffer的几个重要实现 ByteBuffer CharBuffer DoubleBuffer FloatBuffer IntBuffer LongBuffer ShortBuffer 可以通过这些Buffer向Channel数据，或者从Channel读取数据。 使用Buffer来读写数据的步骤 写入数据到Buffer 调用flip()方法 从Buffer中读取数据 调用clear()方法或者compact() 方法 clear()方法会清空整个缓冲区，而compact会清空已经读取过的数据。 Buffer的三个属性，position,limit,capacity capacity 是缓冲区的大小position 写数据时：position表示是当前位置，当前位置写入完毕，position移动到下一个可写的位置， 范围为0~capacity-1.读数据时：position表示当前位置，当前位置读取完毕，position移动到下一个可读位置。 limitlimit表示的是最多能够读取的或者写入的数据的大小。写模式：limit等于capacity读模式：limit等于读模式的position 分配buffer使用allocate()方法来分配Buffer.例如分配一个100字节长的ByteBuffer缓冲区:1ByteBuffer buf = ByteBuffer.allocate(100); 向Buffer中写入数据1.从channel中读取到Buffer中 int bytesRead = inChannel.read(buffer); 2.直接向buffer中put buffer.put(100); 从Buffer中读取数据 1.从Buffer中写数据到Channel int bytesRead = inChannel.write(buffer);2.使用get()方法从Buffer中读取数据 int bytes = buffer.get(); rewind()方法 rewind()方法将position设置为0 Selector Selector最重要的特点就是他允许单线程处理多个Channel. 1.创建Selector 使用Selector的open()方法创建一个Selector 1Selector selector = Selector.open(); 2.注册Channel 将Channel绑定到一起，使用channel.register()来实现。 12channel.configureBlocking(false);Selector key = channel.register(selector,Selectionkey.OP_READ); configureBlocking是设置Channel为非阻塞模式。FileChannel不能和Selector绑定，因为FileChannel没有阻塞模式。 3.SelectionKey SelectorKey是一个抽象类 包含了 interest集合 ready集合 Channel Selector 1.interest集合通过Selector监听Channel时对什么事件感兴趣，可以监听4中类型的事件，分别是OP_CONNECT,OP_ACCEPT,OP_READ,OP_WRITE。 12345int interestSet = selectionKey.interestOps(); boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT； boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT; boolean isInterestedInRead = interestSet &amp; SelectionKey.OP_READ; boolean isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE; 通过&amp;来和SelectorKey常量确定某个事件是在interest集合中。 2.ready集合 ready集合是Channel已经准备就绪的集合。 1234selectionKey.isAcceptable();selectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable(); 3.通过Selector的select()方法选择Channel使用selector的select()方法来返回已经就绪的通道。select()方法会一直阻塞到至少有一个通道在事件上注册了。select()方法返回的int值表示已经有多少个通道已经就绪了4.调用过select()方法后，如果返回的int值大于1则表示已经有至少一个通道已经就绪了，这个时候可以调用Selector的selectedKeys()方法来选择已经就绪的Channel. 1Set selectKeys = selector.selectedKeys(); 遍历这个集合来访问就绪的通道。 123456789101112Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();while(keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable()) &#123; &#125; else if (key.isConnectable()) &#123; &#125; else if (key.isReadable()) &#123; &#125; else if (key.isWritable()) &#123;ng &#125; keyIterator.remove();&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>nio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala中的特质]]></title>
    <url>%2F2016%2F02%2F23%2Ftrait-in-scala%2F</url>
    <content type="text"><![CDATA[特质的构造顺序 1. 超类的构造器 2. 特质由左至右构造 3. 每个特质中，父特质先被构造 4. 多个特质公用一个父特质，而那个特质已经被构造，则不会被再次构造 5. 所有特质构造完毕，子类被构造 eg： 其中 FileLogger和ShortLogger都继承Logger特质 1calss SavingsAccount extends Account with FileLogger with ShortLogger 构造顺序 1.Account（超类） 2.Logger（第一个特质的父特质） 3.FileLogger（第一个特质） 4.ShortLogger（第一个特质） 5.SavingAccount（类） JVM中的特质 由于scala在jvm中运行，所以scala需要将特质翻译为JVM的类与接口 只有抽象方法的特质被简单的翻译成一个Java接口 123trait Logger&#123; def log(msg: String)&#125; 被翻译为 123public interface Logger&#123; void log(String )&#125; 如果特质中有具体的方法，Scala会创建出一个伴生类，伴生类用静态方法存放特质的方法。 12345trait ConsoleLogger extends Logger &#123; def log(msg: String)&#123; println(msg) &#125;&#125; 被翻译成 123public interface ConsoleLogger extends Logger&#123; void log(Stirng msg)&#125; 以及一个和ConsoleLogger接口对应的伴生类 12345public class ConsoleLogger$class&#123; public static void log(ConsoleLogger self, String msg)&#123; println(msg) &#125;&#125;]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小书匠Markdown编辑器，Markdown党的福音]]></title>
    <url>%2F2016%2F01%2F26%2Fxiaoshujiang-markdown%2F</url>
    <content type="text"><![CDATA[安利一个Markdown编辑器，绝对的物超所值，走过路过不要错过哈 O(∩_∩)O~说到印象笔记，很多人都在用，包括在下，剪辑收藏一些网页或者多看阅读同步阅读笔记等体验都很不错，但是一提到Markdown不免有点伤心，因为印象笔记不支持使用Markdown语法，虽说在最新的版本已经加入了一些Markdown的操作，比如输入1.空格 会开始一个数字列表,输入 *空格 会开始一个项目符号列表,等诸如此类一些markdown快捷操作，但是尚未完全支持markdown语法，只能慢慢等大象慢慢开发了。虽说大象有第三方的应用可以支持markdown语法，那就是马克飞象，但是是付费的额，而且功能还有限，就在这时… 逛知乎的时候，看到了一款很棒的markdown编辑器，完全免费，而且支持印象笔记，双向操作即保存和修改，不仅仅支持大象，还支持有道云笔记，为知笔记，Github等等如下图： 对于我这个使用Jekyll自己搭建的blo并且托管在github服务器上的人来说，真是个很好的助手，只要在github端生成一个token和小书匠编辑器进行绑定就可以直接写完操作直接子啊自己的博客上面看到自己写的内容了，除了markdown渲染效果不一样其他的都没什么不同，方便。而且小书匠还支持自定义模板：]]></content>
      <categories>
        <category>杂文其他</category>
      </categories>
      <tags>
        <tag>小书匠</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的null引用]]></title>
    <url>%2F2016%2F01%2F21%2Fnull-reference-in-java%2F</url>
    <content type="text"><![CDATA[空指针也许是java中最常见的异常，到处都埋藏着NullpointerException，最近就遇到一个NullPointException，如下： 1int lastMonthTotalScore = integralOperationReadMapper.getSumByIntegralIdAndDate(integralId, lastMonthDate); 一个很常见的情况，mybatis查询的一个列的和，此时Debug时 integralId、lastMonthDate 都不为空，自动注入的 integralOperationReadMapper也不为空但是Console却实实在在的打出了这一行有一个NullPointerException，此时没有注意到Wrapper类自动转换基本数据类型的情形。 getSumByIntegralIdAndDate 方法返回的是NULL，自动拆箱的时候的要将一个NULL转换为基本数据类型就出错了…o(╯□╰)o 现在总结几个NULL的经验。 1.不用null来返回方法的返回值 不要用null来舒适化变量，方法不要返回null、这样会造成null的传播，在每一个调用的地方都需要检查null 例如： 12345public String doSomething(int id)&#123; String name = findName(id); ... return name;&#125; 这样如果findName如果返回为null，那么null就由findname游走到了doSomething。比如在findname中，如果没有找到对应的Id的姓名，就应该表明是没找到，而不是出错了。 善于运用Java的异常。 1234567public String findName() throws NotFoundException &#123; if (...) &#123; return ...; &#125; else &#123; throw new NotFoundException(); &#125; &#125; 2.不把null放进容器内 容器（collection），是指一些对象以某种方式集合在一起，所以null不应该被放进Array，List，Set等结构，不应该出现在Map的key或者value里面。把null放进容器里面，是一些莫名其妙错误的来源。因为对象在容器里的位置一般是动态决定的，所以一旦null从某个入口跑进去了，你就很难再搞明白它去了哪里，你就得被迫在所有从这个容器里取值的位置检查null。你也很难知道到底是谁把它放进去的，代码多了就导致调试极其困难。解决方案是：如果你真要表示“没有”，那你就干脆不要把它放进去（Array，List，Set没有元素，Map根本没那个entry），或者你可以指定一个特殊的，真正合法的对象，用来表示“没有”。需要指出的是，类对象并不属于容器。所以null在必要的时候，可以作为对象成员的值，表示它不存在。 3.尽早对方法进行参数检查null 应该尽早的对null进行检查，不试图对null进行容错，采用强硬的手段,如果为空则抛出异常，可以使用java.util包里Objects.requireNonNull()方法来给方法的作者回应，告诉方法作者不应该把null传进来。 Objects.requireNonNull()方法如下： 1234567public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) &#123; throw new NullPointerException(); &#125; else &#123; return obj; &#125;&#125; 4.使用Java8的Optional或者guava的Optional Optional类型的设计原理，就是把检查和访问这两个操作合二为一，成为一个原子操作。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala中的模式匹配]]></title>
    <url>%2F2016%2F01%2F14%2Fpattern-matching-in-scala%2F</url>
    <content type="text"><![CDATA[模式匹配scala有一套内建的模式匹配机制，这种机制允许在任何类型的数据上与第一个匹配策略匹配。模式匹配可以应用在很多场合，switch语句，类型检查以及提取对象中的的复杂表达式。 下面是一个小例子，说明如何与一个整型值匹配： 12345678object MatchTest1 extends App &#123; def matchTest(x: Int): String = x match &#123; case 1 =&gt; "one" case 2 =&gt; "two" case _ =&gt; "many" &#125; println(matchTest(3))&#125; 这段带有case的代码块定义了一个从证书向字符串映射的函数关键字match提供了一个便捷的方法来把一个函数apply给一个对象，比如上面的模式匹配函数matchTest。下面是第二个例子匹配不同类型 12345678object MatchTest2 extends App &#123; def matchTest(x: Any): Any = x match &#123; case 1 =&gt; "one" case "two" =&gt; 2 case y: Int =&gt; "scala.Int" &#125; println(matchTest("two"))&#125; 第一个case匹配如果 x是integer类型的且值为1的情况第二个case匹配如果 x是string类型的且值为two的情况Scala的模式匹配语句在通过y样例类来匹配代数类型是最有用的。Scala也允许定义独立自主的对类的匹配，在提取对象使用了预定义的unapply方法。]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同一台电脑使用多个Git账号]]></title>
    <url>%2F2015%2F12%2F25%2Fgit-use-with-mutiusers%2F</url>
    <content type="text"><![CDATA[今天写了文章post到github上发现github并没有记录contribution,使用sourceTree查看提交历史，发现是用公司的git账号提交的，o(╯□╰)o 使用下面命令设置本项目中的用户和邮箱 git config user.name javaor git config user.email hxzhenu@gmail.com]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Scala实现快速排序]]></title>
    <url>%2F2015%2F12%2F25%2Fquicksort-in-scala%2F</url>
    <content type="text"><![CDATA[首先是一个用Scala写的简单的快速排序的栗子（非函数式）： 123456789101112131415161718192021def sort(xs: Array[Int]) &#123; def swap(i: Int, j: Int) &#123; val t = xs(i); xs(i) = xs(j); xs(j) = t &#125; def sort1(l: Int, r: Int) &#123; val pivot = xs((l + r) / 2) var i = l; var j = r while (i &lt;= j) &#123; while (xs(i) &lt; pivot) i += 1 while (xs(j) &gt; pivot) j -= 1 if (i &lt;= j) &#123; swap(i, j) i += 1 j -= 1 &#125; &#125; if (l &lt; j) sort1(l, j) if (j &lt; r) sort1(i, r) &#125; sort1(0, xs.length - 1) &#125; 和Java写的快速排序类似，使用操作符和控制语句来实现，只不过语法和Java有所不同。但是Scala的不同点就在于它的函数式编程，函数式编程可以写出完全不同的程序，更加简单，更加优雅。这次还是快速排序，这一次用函数式的风格来写： 12345678910def quicksort(xs: Array[Int]): Array[Int] = &#123; if (xs.length &lt;= 1) xs else &#123; val pivot = xs(xs.length / 2) Array.concat( quicksort(xs filter (pivot &gt;)), xs filter (pivot ==), quicksort(xs filter (pivot &lt;))) &#125;&#125; 函数式编程用一种简洁的方式抓住了快速排序的本质 如果数组array是空的或者只有一个元素那么肯定是已经排好序的所以直接返回 如果数组array不是空的,选择数组中间的元素当做pivot。 将数组划分为三个子数组,分别包含笔pivot大、小、相等的元素。 对于大于和小于pivot的子元素的数组递归调用sort函数。 讲三个子数组组合在一起就是排序结果。]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程语言Scala的学习（Hello Scala）]]></title>
    <url>%2F2015%2F12%2F20%2Flearning-scala%2F</url>
    <content type="text"><![CDATA[Scala吸收了收并继承了多种语言中的优秀特性，另一方面也没有抛弃Java这个强大的平台，它可以运行在 Java 虚拟机之上，能够轻松地与Java互联互通。与Java不同的是，Scala既支持面向对象的特性，又支持函数式编程，被称为是Java的替代语言，是更好的Java，下面开始学习这一强大的语言。 Scala和Java比较在Scala中 所有类型都是对象 函数是对象 支持Domain specific language (DSL)领域特定语言 特质(Trait) 闭包(Closure)，嵌套函数 Erlang支持的并发设计 类型推导 基础语法表达式scala&gt; 1 + 1 res0: Int = 2 res0是解释器自动创建的变量名称，指代表达式计算的结果，是Int类型的，值为2。在scala几乎一切都是表达式。 变量和值可以将表达式赋给一个或者不变量（val）–值或者变量（var） scala&gt; val two = 1 + 1 two: Int = 2 如果需要以后修改这个名称和结果的绑定，需要使用var（变量），大部分的情况下用val的情况居多。 scala&gt; var name = "zhaohongxuan" name: java.lang.String = zhaohongxuan scala&gt; name = "zhaoxiaoxuan" name: java.lang.String = zhaoxiaoxuan 函数使用def关键字来创建函数 scala&gt; def addOne(m: Int): Int = m + 1 addOne: (m: Int)Int 调用函数： scala&gt; val three = addOne(2) three: Int = 3 在scala中，需要为函数参数制定类型的签名。但是，如果函数不带参数，括号可以省略。 scala&gt; def three() = 1 + 2 three: ()Int scala&gt; three() res2: Int = 3 scala&gt; three res3: Int = 3 匿名函数创建匿名函数 scala&gt; (x: Int) =&gt; x + 1 res2: (Int) =&gt; Int = &lt;function1&gt; 这个函数的作用是给名为x的变量加1. scala&gt; res2(1) res3: Int = 2 也可以传递匿名函数 scala&gt; val addOne = (x: Int) =&gt; x + 1 addOne: (Int) =&gt; Int = &lt;function1&gt; scala&gt; addOne(1) res4: Int = 2 如果函数中表达式很多，可以用花括号{}来格式化代码、 scala&gt; { i: Int =&gt; println("hello world") i * 2 } res0: (Int) =&gt; Int = &lt;function1&gt; 部分应用（Partial application）可以使用下划线_部分应用一个函数，结果是得到另一个函数。 定义一个add函数 scala&gt; def add(m: Int, n: Int) = m + n add: (m: Int,n: Int)Int 将add函数部分应用得到一个新的匿名函数 scala&gt; val add2 = add(2, _:Int) add2: (Int) =&gt; Int = &lt;function1&gt; scala&gt; add2(3) res50: Int = 5 可变长度参数这是一种特殊的语法，可以向方法传入任意多个同类型的参数。比如给传入的参数的首字母进行大写的操作。 def capitalizeAll(args: String*) = { args.map { arg =&gt; arg.capitalize } } scala&gt; capitalizeAll("zhaoxiaoxuan", "douxiaonna") res2: Seq[String] = ArrayBuffer(Zhaoxiaoxuan, Douxiaonna) 类、继承与特质类scala&gt; class Calculator { | val brand: String = "HP" | def add(m: Int, n: Int): Int = m + n | } defined class Calculator scala&gt; val calc = new Calculator calc: Calculator = Calculator@e75a11 scala&gt; calc.add(1, 2) res1: Int = 3 scala&gt; calc.brand res2: String = "HP" 这个计算器类展示了在类中使用def定义方法，和使用val定义字段。其中方法就是可以可以访问类状态的函数。 构造函数构造函数不是特殊的方法，他们是除了类的方法定义之外的代码。 class Calculator(brand: String) { //构造函数 val color: String = if (brand == "TI") { "blue" } else if (brand == "HP") { "black" } else { "white" } // An instance method. def add(m: Int, n: Int): Int = m + n } 使用构造函数来构造一个实例： scala&gt; val calc = new Calculator("HP") calc: Calculator = Calculator@1e64cc4d scala&gt; calc.color res0: String = black 在上面的例子中，颜色的值就是绑定在一个if/else表达式上的。Scala是高度面向表达式的：大多数东西都是表达式而非指令。 继承1234567891011121314class Point(xc: Int, yc: Int) &#123; val x: Int = xc val y: Int = yc def move(dx: Int, dy: Int): Point = new Point(x + dx, y + dy)&#125;class ColorPoint(u: Int, v: Int, c: String) extends Point(u, v) &#123; val color: String = c def compareWith(pt: ColorPoint): Boolean = (pt.x == x) &amp;&amp; (pt.y == y) &amp;&amp; (pt.color == color) override def move(dx: Int, dy: Int): ColorPoint = new ColorPoint(x + dy, y + dy, color)&#125; ColorPoint继承了Point中所有的成员，包括x,y包括move方法。 子类ColorPoint增加了一个新的方法compareWith。Scala允许对成员定义进行覆盖（Override），在这个例子中，我们在子类中用move方法覆盖了的父类的move方法,当然在子类中可以使用super关键字来调用父类的move方法。 抽象类定义一个抽象类，它定义了一些方法但没有实现它们。取而代之是由扩展抽象类的子类定义这些方法。抽象类不能创建实例。 scala&gt; abstract class Shape { | def getArea():Int // subclass should define this | } defined class Shape scala&gt; class Circle(r: Int) extends Shape { | def getArea():Int = { r * r * 3 } | } defined class Circle scala&gt; val s = new Shape &lt;console&gt;:8: error: class Shape is abstract; cannot be instantiated val s = new Shape ^ scala&gt; val c = new Circle(2) c: Circle = Circle@65c0035b 特质特质是一些字段和行为的集合，可以扩展或者混入（Mixin）你的类中。 trait Car { val brand: String } trait Shiny { val shineRefraction: Int } class BMW extends Car { val brand = "BMW" } 通过with关键字，一个类可以扩展多个特质： class BMW extends Car with Shiny { val brand = "BMW" val shineRefraction = 12 }]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spring boot 创建RestFul服务]]></title>
    <url>%2F2015%2F11%2F29%2Fspring-boot-restful%2F</url>
    <content type="text"><![CDATA[准备工作1.JDK82.Maven 3.0+ 程序要实现的简单功能当用户访问 http://localhost:8080/greeting 返回一个默认的Json字符串 {"id":1,"content":"Hello, World!"} 当用户访问 http://localhost:8080/greeting?name=User 返回 name后面的参数在后台组成的字符串 {"id":1,"content":"Hello, User!"} 创建Maven项目创建一个普通的maven项目，添加maven依赖如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.zeusjava&lt;/groupId&gt; &lt;artifactId&gt;SpringMVCRESTFul&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 各个包之间的依赖关系如下图： ##创建一个resource representation 类To model the greeting representation, you create a resource representation class.Provide a plain old java object with fields, constructors, and accessors for the id and content data: 创建一个User类，有id和name两个属性 1234567891011121314151617181920package com.zeusjava;public class User &#123; private final long id; private final String name; public User(long id, String name) &#123; this.id = id; this.name = name; &#125; public long getId() &#123; return id; &#125; public String getName() &#123; return name; &#125;&#125; 当用户访问URL的时候，程序后台会自动获得URL上附带的名为name的参数。 创建一个resource controller在Spring4中新增了一个@RestController注解，相当于Spring3中的@Controller和@ResponseBody两个注解一起的效果创建一个UserController来处理Request如下： 12345678910111213141516171819202122package com.zeusjava;import java.util.concurrent.atomic.AtomicLong;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class UserController &#123; private static final String template = "Hello, %s!"; private final AtomicLong counter = new AtomicLong(); @RequestMapping("/greeting") public User greeting(@RequestParam(value="name", defaultValue="World") String name) &#123; return new User(counter.incrementAndGet(), String.format(template, name)); &#125;&#125; 执行程序main方法使用Spring Boot 的SpringApplication.run()来加载程序。 123456789101112package com.zeusjava;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 测试程序在Application的main方法中运行application，在地址栏输入 http://localhost:8080/greeting 结果为： 再输入一次 http://localhost:8080/greeting?name=Zhaohongxuan 结果为： 不用配置繁琐的xml，一个简单的Restful风格的程序就创建好了。]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>RESTFul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jersey创建RESTful服务]]></title>
    <url>%2F2015%2F11%2F18%2Fjava-restful-jersey-learn%2F</url>
    <content type="text"><![CDATA[REST基础概念首先REST是Representational State Transfer的缩写，如果一个架构符合REST原则，它就是RESTful架构。在REST中的一切都被认为是一种资源。所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 我们把”资源”具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。URI只代表资源的实体，不代表它的形式。URI只代表资源的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生状态转化（State Transfer）。而这种转化是建立在表现层之上的，所以就是表现层状态转化。客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 Jersey RESTfulJersey RESTful 框架是开源的RESTful框架, 实现了JAX-RS 规范。它扩展了JAX-RS 参考实现， 提供了更多的特性和工具， 可以进一步地简化 RESTful service 和 client 开发。尽管相对年轻，它已经是一个产品级的RESTful service和client框架。有关Jersey文档请点击Jersey文档下面介绍使用Maven与Jersey编写一个简单的RestFul服务的栗子。 在intellij中创建RestFul栗子加入Maven包依赖123456789101112131415161718192021222324252627282930&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-server&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.ws.rs&lt;/groupId&gt; &lt;artifactId&gt;jsr311-api&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt; 在Web.xml文件中定义Servlet调度程序定义一个初始化参数，指示包含资源的Java包，我把Resource都放在了com.zeusjava.resource里了,所有的资源通过http://localhost:8081/jersey/api/来访问 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt;&lt;display-name&gt;JerseyRestFul&lt;/display-name&gt;&lt;servlet&gt; &lt;servlet-name&gt;JerseyRestFul&lt;/servlet-name&gt; &lt;servlet-class&gt;com.sun.jersey.spi.container.servlet.ServletContainer&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;com.sun.jersey.config.property.packages&lt;/param-name&gt; &lt;param-value&gt;com.zeusjava.resource&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;JerseyRestFul&lt;/servlet-name&gt; &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 创建资源文件资源是Rest中最重要的部分，可以通过Http的方法 GET、POST、PUT 和DELETE等对资源进行增删改查，下面创建的UserResource中实现了对User的增删改查，用户存储在UserCache的一个Map中，在JAX-RX中，资源通过POJO实现，使用@Path 注释组成其标识符。资源可以有子资源。在这种情况下，父资源是资源集合，子资源是成员资源。 增加一个User注解@Path(&quot;/users&quot;)将UserResource暴露为一个Rest服务，注解@POST将HTTP方法映射到资源的 让POST方法变成创建方法。 @Consumes：声明该方法使用 HTML FORM即表单输入。 @FormParam：注入该方法的 HTML 属性确定的表单输入。 @Response.created(uri).build()： 构建新的 URI 用于新创建的User（/users/{id}）并设置响应代码（201/created）。您可以使用 http://localhost:8081/jersey/api/users/ 访问新用户。 @Produces：限定响应内容的MIME类型。MIME类型有很多种，XML和JSON是常用的两种 @Context： 使用该注释注入上下文对象，比如 Request、Response、UriInfo、ServletContext 等。 1234567891011121314151617181920212223242526@Path("/users")public class UserResource &#123; @Context UriInfo uriInfo; /** * 增加用户 * @param userId * @param userName * @param userAge * @param servletResponse * @throws IOException */ @POST @Consumes(MediaType.APPLICATION_FORM_URLENCODED) public void newUser( @FormParam("userId") String userId, @FormParam("userName") String userName, @FormParam("userAge") int userAge, @Context HttpServletResponse servletResponse ) throws IOException &#123; User user = new User(userId,userName,userAge); UserCache.getUserCache().put(userId,user); URI uri = uriInfo.getAbsolutePathBuilder().path(userId).build(); Response.created(uri).build(); &#125;&#125; 删除用户 @DELETE将Http Delete请求绑定到删除用户（资源）操作上 @PathParam该注释将参数注入方法参数的路径 1234567@DELETE @Path("/&#123;id&#125;") public void deleteContact(@PathParam("id") String id) &#123; User user = UserCache.getUserCache().remove(id); if(user==null) throw new NotFoundException("No such User."); &#125; 更新用户根据用户的Id来更新一个用户（资源）。Consume XML：putContact() 方法接受 APPLICATION/XML 请求类型，而这种输入 XML 将使用 JAXB 绑定到 User 对象。PUT 请求的响应没有任何内容，但是有不同的状态码。如果Cache中存在联系人，我将更新该User并返回 204/no content。如果没有User，我将创建一个并返回 201/created。 12345678910111213141516171819/** * 更新用户 * @param jaxbContact * @return */@PUT@Path("/&#123;id&#125;")@Consumes(MediaType.APPLICATION_XML)public Response putUser(JAXBElement&lt;User&gt; jaxbContact,@PathParam("id") String id) &#123; User user = jaxbContact.getValue(); Response res; if(UserCache.getUserCache().containsKey(id)) &#123; res = Response.noContent().build(); &#125; else &#123; res = Response.created(uriInfo.getAbsolutePath()).build(); &#125; UserCache.getUserCache().put(user.getUserId(), user); return res;&#125; 查找用户根据传入的id查找用户，如果没有用户则抛出异常。返回类型为MediaType.APPLICATION_XML需要在JavaBean中设置@XmlRootElement注解。 1234567891011@GET @Path("/&#123;id&#125;") @Produces(MediaType.APPLICATION_XML) public User getUser(@PathParam("id") String id) &#123; User user = UserCache.getUserCache().get(id); if(user==null)&#123; throw new NotFoundException("No such User."); &#125; return user; &#125; User实体类1234567891011121314151617181920212223242526272829package com.zeusjava.entity;import javax.xml.bind.annotation.XmlRootElement;/** * Created By IntelliJ IDEA. * User: LittleXuan * Date: 2015/11/18. * Time: 17:05 * Desc: User实体类 */@XmlRootElementpublic class User &#123; private String userId; private String userName; private int userAge; public User()&#123; &#125; public User(String userId, String userName, int userAge) &#123; this.userId = userId; this.userName = userName; this.userAge = userAge; &#125; //getter&amp;setter &#125; User缓存类123456789101112131415161718192021222324252627282930313233package com.zeusjava.cache;import com.zeusjava.entity.User;import java.util.HashMap;import java.util.Map;/** * Created By IntelliJ IDEA. * User: LittleXuan * Date: 2015/11/19. * Time: 9:17 * Desc: UserCache 存储用户 */public class UserCache &#123; private static Map&lt;String,User&gt; userCache; private static UserCache instance = null; private UserCache() &#123; userCache = new HashMap&lt;String,User&gt;(); initOneUser(); &#125; public static Map&lt;String,User&gt; getUserCache() &#123; if(instance==null) &#123; instance = new UserCache(); &#125; return userCache; &#125; private static void initOneUser() &#123; User user = new User("001","zhaohongxuan",24); userCache.put(user.getUserId(),user); &#125;&#125; 创建Client测试测试代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.zeusjava.client;import javax.ws.rs.core.MediaType;import javax.xml.bind.JAXBElement;import com.sun.jersey.api.client.Client;import com.sun.jersey.api.client.ClientResponse;import com.sun.jersey.api.client.GenericType;import com.sun.jersey.api.client.WebResource;import com.sun.jersey.api.representation.Form;import com.zeusjava.entity.User;import org.junit.Test;public class UserClient &#123; private WebResource r = null; @Test public void insertUser()&#123; r = Client.create().resource("http://localhost:8081/jersey/api/users"); Form form = new Form(); form.add("userId", "002"); form.add("userName", "ZhaoHongXuan"); form.add("userAge", 23); ClientResponse response = r.type(MediaType.APPLICATION_FORM_URLENCODED) .post(ClientResponse.class, form); System.out.println(response.getStatus()); &#125; @Test public void findUser()&#123; r = Client.create().resource("http://localhost:8081/jersey/api/users/002"); String jsonRes = r.accept(MediaType.APPLICATION_XML).get(String.class); System.out.println(jsonRes); &#125; @Test public void updateUser()&#123; r = Client.create().resource("http://localhost:8081/jersey/api/users"); User user = new User("002","ZhaoXiaoXuan",24); ClientResponse response = r.path(user.getUserId()).accept(MediaType.APPLICATION_XML) .put(ClientResponse.class, user); System.out.println(response.getStatus()); &#125; @Test public void deleteUser()&#123; r = Client.create().resource("http://localhost:8081/jersey/api/users"); GenericType&lt;JAXBElement&lt;User&gt;&gt; generic = new GenericType&lt;JAXBElement&lt;User&gt;&gt;() &#123;&#125;; JAXBElement&lt;User&gt; jaxbContact = r .path("002") .type(MediaType.APPLICATION_XML) .get(generic); User user = jaxbContact.getValue(); System.out.println(user.getUserId() + ": " + user.getUserName()); ClientResponse response = r.path("002").delete(ClientResponse.class); System.out.println(response.getStatus()); &#125;&#125; 测试程序服务器使用tomcat启动（本步略）1.首先运行insertUserTest方法添加一个用户 返回响应码201表示创建成功。2.运行findUser查询id为002的用户 &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;user&gt;&lt;userAge&gt;23&lt;/userAge&gt;&lt;userId&gt;002&lt;/userId&gt;&lt;userName&gt;ZhaoHongXuan&lt;/userName&gt;&lt;/user&gt; 服务器响应的是我们刚才添加的用户3.运行updateUser更新用户名为ZhaoXiaoXuan,年龄为24 返回响应码为204表示更新成功 再次查询id为002的用户 &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;user&gt;&lt;userAge&gt;24&lt;/userAge&gt;&lt;userId&gt;002&lt;/userId&gt;&lt;userName&gt;ZhaoXiaoXuan&lt;/userName&gt;&lt;/user&gt; 用户名称和年龄已经更改为`ZhaoxiaoXuan`和`24` 4.运行deleteUser删除用户 结果如下： 002: ZhaoXiaoXuan 204 表示删除成功再次运行查询，则服务器报404错误，说明该用户已经被删除。 GET http://localhost:8081/jersey/api/users/002 returned a response status of 404 完整的使用Jersey创建服务的代码地址为：JerseyRestFul]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java RESTFul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑在立冬边上]]></title>
    <url>%2F2015%2F11%2F09%2Frunning-like-an-animal%2F</url>
    <content type="text"><![CDATA[村上春树说， 今天不想去跑步，所以才去跑步，这才是长跑者的思维 因为这句话，我专门买了村上君的《当我谈跑步的时，我谈些什么》，这本书让我对跑步有了更加深层次的认识。今天是2015年立冬，跑步也进入到了一年中最艰难的时候，上海的立冬并没有那么的冷，前一阵子冷空气经过上海的时候，冷了那么几天，但是过后天气又变得温暖起来了，算起来，从7月20号开始跑步到现在也快4个月了，也跑了将近500公里了。从蝉鸣的夏季，到燥热的秋季，再到冷风习习的冬季，时光就在脚步的一抬一落间逝去了，从身体流走的汗水已经数不清到底有多少了，喜欢奔跑的感觉，喜欢超越昨天自己的感觉，汗水浸润每一个细胞，感觉自己是真的自己。 十月份的国庆节中间耽误了一周没有跑步，所以国庆节一过便迫不及待的跑了起来，连着两周跑了半程马拉松，成绩也都还不错，都在2个小时之内,都是线上跑的，自己在学校的时候也跑过全程马拉松，但是，那是白天，而且有好多人一起跑，和现在不同，现在是一个人跑，而且是晚上，还有的路段，没有路灯，但是跑下来竟然没有感觉脚起泡，而且腿似乎也没有感觉特别酸痛，只是过了一天才感觉到。跑步，让自己的内心平静了很多，不管有多么不开心的事情，去跑步了，淋漓大汗过后，就会发现，其实也不过如此，哪有什么天大的事。再次，跑步让我明白了一个非常非常浅的道理，那就是，just do it. 以前做事情的时候，总是在想别人看到会怎么样，会怎么说，其实，哪有那么多闲人在意你在做什么，你去跑步根本没有人在意你，就算有人说你了，TA又和你没有半点交集怕什么，当你真正穿上跑鞋，在路上奔跑的时候，你会发现世界都是你的，每次跑完10公里，在栏杆上压腿的时候，感觉到自己的心跳和呼吸，但是心里却是很平静，我希望跑步能陪我很久很久。 这几天，上海的天气一点都不好，只要一出门跑步肯定是不会下雨的，但是等自己跑到一半的时候就开始下了，就这样连着三天，每天都被雨淋，但是感觉当雨水打在脸上的时候，会发现自己的脚步更加坚定了，因为觉得，老子连在雨里跑步都不怕，还会怕什么呢，哈哈。经过了一年最热的日子，去迎接美好的冬天，用心去过好每一天，发现身边的美。 老罗说， 失败只有一种，那便是半途而废. 回想自己，从去年12月开始捡起英语，到今天一天都不曾间断过，这可能也算是一种坚持，感觉自己萌萌哒。 不去跑永远不知道自己能跑多久，能跑多远，刚开始跑步的时候78公斤，现在76公斤，跑了4个月减了4公斤，其实没有瘦多少，其实当初跑步的时候，并不全是为了要减重，最重要的是想要更加健康的身体吧。年轻的时候就是要多做三件事： 1.多挣钱2.多读书3.多锻炼 多挣钱，让物质生活更加自由，多读书让精神更加自由，多锻炼，让生活更加自由。继续奔跑吧，坚持做你认为正确的事情！]]></content>
      <categories>
        <category>杂文其他</category>
      </categories>
      <tags>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Executor任务执行框架的应用]]></title>
    <url>%2F2015%2F11%2F09%2Fjava-concurrent-executor-and-countdownlatch%2F</url>
    <content type="text"><![CDATA[最近一段时间没有写东西了，看大名鼎鼎的Brian Goetz写的Java Concurrency in Practice时候，看到任务执行框架Executor Framework的时候，觉得纸上得来终觉浅，索性写点东西加深一下印象。 在JDK1.5中，Java平台中增加了一个并发包java.util.concurrent，这个包中包含了Executor Framework，而且还包含了很多并发包，比如并发HashMapConcurrentHashMap、阻塞队列BlockQueue、栅栏的实现CyclicBarrier、信号量Semaphore、异步任务FutureTask等等。在处理多线程任务的时候，使用Executor和task要优于使用线程,这也不是我说的，是Effect Java的作者 Joshua Bloach说的，下面来阐述一下为什么。 并发任务执行当要执行一个并发任务的时候，通常有两种方式，一种是串行的处理方式，一种是并行的处理,显然，串行的方式只能一次处理一个任务，当程序在执行当前的任务的时候，就说明接下来到来的任务请求都要等待当前的任务执行完毕才能获得CPU去执行任务，这种方式虽然不会犯错，但是效率太低。那么，如果每一个任务到来都分配一个新的任务呢，这种方式貌似很好，但是： 如果任务请求量非常大的时候会出现一定的问题，因为它没有限制可以创建的线程的数量. 线程生命周期的开销很高 线程的创建和销毁不是没有代价的,根据平台的不同，开销不同，但是不要忘记，线程的创建是需要时间的。 活跃的线程会消耗系统资源 活跃的线程很消耗系统资源，尤其是内存，如果可运行的线程数量多于处理器核心数，那么多余的线程将闲置，但是闲置的线程仍然是消耗系统资源的，尤其 是内存，给GC回收垃圾带来压力，而且线程间在进行竞争的时候也会消耗大量的资源 平台可创建的线程数量是有限的 也就是说，如果创建的线程超出了平台的限制那么，JVM就可能抛出OutofMemoryError的异常 线程池和数据库连接池相似，线程池指的是一组同构工作线程的资源池，线程池与工作队列 Work Queue密切相关线程池中的线程的任务很简单：从工作队列（Work Queue）中取出一个任务，执行任务，人后返回线程池，等待执行下一个任务 线程池比为每一个任务分配一个线程要有更多优势，通过重用现有线程而不是重新创建线程，可以处理多个任务请求的时候，分摊在线程创建和销毁的过程中产生的巨大开销。而且，当请求到达的时候，线程池中的线程也已经就绪，不需要在创建线程而延迟响应的时间，提高了响应性。通过调整线程池的大小，可以创建足够多的线程来让CPU保持忙碌的状态。 创建线程池有很多种方式， 通过调用Executors的工厂方法可以创建线程池，例如：newFixThreadPool 用来创建一个固定长度的线程池newCacheThreadPool 用来创建一个可缓存的线程池newSingleThreadPool 创建一个单线程的线程池 Executor框架任务和线程不同，任务是一组逻辑工作单元，而线程是使任务异步执行的机制。在Java类库中，任务执行的主要抽象不是Thread而是Executor Executor接口定义如下 1234567891011121314public interface Executor &#123; /** * Executes the given command at some time in the future. The command * may execute in a new thread, in a pooled thread, or in the calling * thread, at the discretion of the &lt;tt&gt;Executor&lt;/tt&gt; implementation. * * @param command the runnable task * @throws RejectedExecutionException if this task cannot be * accepted for execution. * @throws NullPointerException if command is null */ void execute(Runnable command);&#125; 虽然Executor只是一个简单的接口，但是却为灵活而强大的异步任务执行框架提供了基础。其中Runnable表示可以执行的任务Executor的实现还提供了对生命周期的支持。 Executor基于 生产者-消费者模式，提交任务到线程池相当于生产者，执行任务相当于消费者。 闭锁闭锁是一种同步工具类，作用是延迟线程的进度直到其到达终止状态。 ###举个栗子：闭锁的作用相当于一扇门，当闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过,当闭锁到达技术状态的时候，这扇门会打开而让所有线程通过。当闭锁到达结束状态的时候，这扇门会永远保持打开状态。闭锁的作用是，可以用来确保某些活动直到其他活动都完成后才执行。 实践纸上得来终觉浅，写了代码就知道为什么了。 还比如上一次写的爬虫，如果单线程抓取的话，只能首先抓取首页，然后解析其中的图片链接，然后再下载图片，这样效率无疑是很低的，现在我加上线程池。 建立工作队列一个是抓取页面的阻塞队列naviQueue,一个是抓取页面上的图片url的阻塞队列imgQueue 1234 // 定义一个页面导航的队列final BlockingQueue&lt;String&gt; naviQueue = new LinkedBlockingQueue&lt;String&gt;(3);// 定义一个图片网址的队列final BlockingQueue&lt;String&gt; imgQueue = new LinkedBlockingQueue&lt;String&gt;(100); 创建线程池线程池的大小是下载图片线程和解析页面线程的数量之和 123final int DOWNLOAD_THREAD = 30;final int PAGE_THREAD = 2;final ExecutorService exec = Executors.newFixedThreadPool((DOWNLOAD_THREAD + PAGE_THREAD)); 定义闭锁定义一个开始倒数锁和一个结束倒数锁 1234// 定义一个开始的倒数锁final CountDownLatch begin = new CountDownLatch(1);// 定义一个结束的倒数锁final CountDownLatch end = new CountDownLatch((DOWNLOAD_THREAD + PAGE_THREAD)); 其中，开始倒数锁的作用是，等待主线程加载首页信息，加载完成后才能继续抓取下一页的URL，所以开始倒数锁的初始大小为1，等初始化线程一旦执行完毕之后，立刻释放所有的线程，开始执行并行任务。 结束倒数锁的作用是，主线程能够等待所有的工作线程依次执行完成，而不是顺序的等待每个线程执行完毕。 初始化线程123456789101112131415161718192021public ThreadPoolMananger() &#123; int i = 1; for (; i &lt;= PAGE_THREAD; i++) &#123; exec.submit(new PageThread(i, begin, end)); &#125; for (; i &lt;= (DOWNLOAD_THREAD + PAGE_THREAD); i++) &#123; exec.submit(new ImageThread(i, "D:\\pictures", begin, end)); &#125; HtmlParser parser = new HtmlParser(); SimpleHttpClient client = new SimpleHttpClient(); parser.setHtml(client.get("http://jandan.net/pic")); System.out.println("====开始抓取首页"); try &#123; naviQueue.put(parser.getPageNavi()); parser.handleImgs(imgQueue); &#125; catch (InterruptedException e) &#123; &#125; client.close(); System.out.println("首页结束，开始执行多线程抓取"); begin.countDown();&#125; 构造器中初始化了页面抓取线程和一些下载图片的线程到线程池中，然后开始执行首页的抓取，等待首页抓取完毕之后，begin.coutDown(),这时候开始门的大小为0，这时候会释放所有的工作线程，开始执行多线程的抓取工作。 页面处理线程页面抓取线程在初始化主线程执行完毕之后开始执行，从页面URL队列naviQueue中取出队列头部的url，使用Jsoup进行解析，得到本页面所有的图片url并添加到待处理的图片URL队列imgQueue中然后得到下一页的链接URL，加入naviQueue中，如果在解析的过程中发现，Jsoup解析的下一页为空，那么就说明已经解析完成了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class PageThread implements Runnable &#123; private final CountDownLatch startSignal; private final CountDownLatch stopSignal; private int index; public PageThread(int index, CountDownLatch start, CountDownLatch end) &#123; this.startSignal = start; this.stopSignal = end; this.index = index; &#125; @Override public void run() &#123; try &#123; startSignal.await(); &#125; catch (Exception e) &#123; &#125; String html = ""; String url = ""; int left = 0; HtmlParser parser = new HtmlParser(); SimpleHttpClient client = new SimpleHttpClient(); while (true) &#123; try &#123; url = naviQueue.take(); left = naviQueue.size(); if ("".equals(url)) &#123; // 把结束的标志放回去，其他的线程也要调用 naviQueue.put(""); break; &#125; &#125; catch (Exception e) &#123; System.err.println("[" + index + "]:" + e.getMessage()); &#125; System.out.println("[" + index + "][页面left:" + left + "]线程抓取html--&gt;" + url); try &#123; html = client.get(url); &#125; catch (Exception e1) &#123; &#125; parser.setHtml(html); String next = parser.getPageNavi(); try &#123; if (next == null) &#123; naviQueue.put(""); parser.handleImgs(imgQueue); // 在图片队列的最后也放上一个""作为结束的标志 imgQueue.put(""); &#125; else &#123; naviQueue.put(next); parser.handleImgs(imgQueue); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; client.close(); stopSignal.countDown(); &#125; &#125; 图片下载线程图片线程的主要任务就是下载所有的图片并保存到本地。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ImageThread implements Runnable &#123; private final CountDownLatch startSignal; private final CountDownLatch stopSignal; private int threadIdx; private String dest; public ImageThread(int index, String dest, CountDownLatch start, CountDownLatch end) &#123; this.threadIdx = index; this.dest = dest; this.startSignal = start; this.stopSignal = end; &#125; @Override public void run() &#123; try &#123; // 等待初始的线程结束 startSignal.await(); &#125; catch (Exception e) &#123; &#125; System.out.println("[" + threadIdx + "]线程开始"); SimpleHttpClient client = new SimpleHttpClient(); String picurl = ""; int left = 0; // 这个线程不断的从图片队列里面取出图片的地址 while (true) &#123; // 取出一个图片地址 try &#123; picurl = imgQueue.take(); left = imgQueue.size(); &#125; catch (InterruptedException e1) &#123; System.err .println("[" + threadIdx + "]:" + e1.getMessage()); &#125; if ("".equals(picurl)) &#123; try &#123; // 结束标志，丢回去，其他的线程要根据这个判断结束 imgQueue.put(""); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 如果说，取到图片地址为空而且页面的已经解析完毕，这个就应该要结束了。 break; &#125; try &#123; System.out.println("[" + threadIdx + "][图片left:" + left + "]线程开始抓取image--&gt;" + picurl); client.downloadFile(picurl, dest); &#125; catch (Exception e) &#123; System.err.println("[" + threadIdx + "]:" + e.getMessage()); &#125; &#125; client.close(); stopSignal.countDown(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Spring中使用Ehcache]]></title>
    <url>%2F2015%2F10%2F26%2Fuse-ehcache-in-spring%2F</url>
    <content type="text"><![CDATA[首先是所需要的包的Maven依赖1.ehcache的核心包 123456&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; 2.Spring-context-support中包含和缓存、Scheduler有关的类方法等 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt;&lt;/dependency&gt; 编写Ehcache配置文件ehcache.xml12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd" updateCheck="false"&gt; &lt;diskStore path="java.io.tmpdir" /&gt; &lt;defaultCache eternal="false" maxElementsInMemory="1000" overflowToDisk="false" diskPersistent="false" timeToIdleSeconds="0" timeToLiveSeconds="600" memoryStoreEvictionPolicy="LRU" /&gt; &lt;cache name="serviceCache" eternal="false" maxElementsInMemory="100" overflowToDisk="false" diskPersistent="false" timeToIdleSeconds="0" timeToLiveSeconds="300" memoryStoreEvictionPolicy="LRU" /&gt;&lt;/ehcache&gt; 在Spring配置文件中添加ehcache配置信息1234&lt;!-- 使用ehcache缓存 --&gt;&lt;bean id="ehCacheManager" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt; &lt;property name="configLocation" value="classpath:ehcache.xml" /&gt;&lt;/bean&gt; 项目启动时候，Spring 容器会加载缓存，还需要一个缓存管理类来进行缓存的管理。 建立缓存管理类EhCacheManagerEhcacheManager中的CACHE_KEY是和ehcache.xml中的cache name保持一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import net.sf.ehcache.CacheManager;import net.sf.ehcache.Ehcache;import net.sf.ehcache.Element;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.Serializable;/** * Created by LittleXuan on 2015/10/24. * 缓存管理类 */public class EhCacheManager &#123; private static Logger log = LoggerFactory.getLogger(EhCacheManager.class); private static final String CACHE_KEY ="serviceCache"; public static final int CACHE_LIVE_SECONDS = 180; private static EhCacheManager instance = new EhCacheManager(); private static CacheManager cacheManager; private static Ehcache fileCache; private EhCacheManager() &#123; log.info("初始化缓存 ----------------------------------------"); cacheManager = new CacheManager(); fileCache = cacheManager.getCache(CACHE_KEY); log.info("初始化缓存成功...."); &#125; public static synchronized EhCacheManager getInstance() &#123; if (instance == null) &#123; instance = new EhCacheManager(); &#125; return instance; &#125; public static byte[] loadFile(String key) &#123; Element e = fileCache.get(key); if (e != null) &#123; Serializable s = e.getValue(); if (s != null) &#123; return (byte[]) s; &#125; &#125; return null; &#125; public static void cacheFile(String key, byte[] data) &#123; fileCache.put(new Element(key, data)); &#125; /** * 将数据存入缓存，缓存无时间限制 * @param key * @param value */ public static &lt;T&gt; void put(String key,T value)&#123; fileCache.put(new Element(key, value)); &#125; /** * 通过key值获取存入缓存中的数据 * @param key 数据存入缓存时的key */ @SuppressWarnings("unchecked") public static &lt;T&gt; T get(String key) &#123; Element el = fileCache.get(key); if (el == null) &#123; if (log.isDebugEnabled()) log.debug("not found key:"+ key); return null; &#125; T t = (T) el.getObjectValue(); return t; &#125; /** * 根据key删除缓存 */ public static boolean remove(String key) &#123; log.info("remove key:"+key); return fileCache.remove(key); &#125; /** * 关闭cacheManager 对象 */ public static void shutdown() &#123; cacheManager.shutdown(); &#125;&#125; 创建Service类123456789101112131415161718192021@Service("userService")public class UserServiceImpl extends BaseServiceImpl&lt;User,userMapper&gt; implements IUserService &#123; private final static String GET_USER_KEY ="GET_USER_KEY_"; @Resource private UsertMapper userMapper; @Override public List&lt;User&gt; selectUserById(String userId) &#123; //从缓存中查找 User user = EhCacheManager.get(GET_USER_KEY+userId); if(user == null)&#123; User queryUser = new User(); queryUser.setUserId(userId); log.info("第一次加载，缓存为空从数据库中查找..."); user = userMapper.selectOne(queryUser); //将从数据库中查询到的结果放入缓存 EhCacheManager.put(GET_USER_KEY+userId,user); &#125; return user; &#125;&#125; 创建测试类12345678910111213141516171819202122232425262728@RunWith(SpringJUnit4ClassRunner.class) //表示继承了SpringJUnit4ClassRunner类@ContextConfiguration(locations = &#123;"classpath:spring-mybatis.xml"&#125;)public class UserTest &#123; private static Logger logger = LoggerFactory.getLogger(UserTest.class); @Resource private IUserService userService = null; @Test public void test1() &#123; User userResult = this.userService.selectUserById("0001"); &#125;&#125;@Controller@RequestMapping("/user")public class CacheTest &#123; private static Logger logger = LoggerFactory.getLogger(CacheTest.class); @Resource private IConstantService constantService; @RequestMapping("/userInfo") public void testConstant() &#123; User userResult = this.userService.selectUserById("0001"); System.out.println("username:"+userResult.getUsername()); &#125;&#125; 运行结果第一次请求 初始化缓存 ---------------------------------------- 初始化缓存成功.... username:赵宏轩 接下来请求 username:赵宏轩]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>ehcache</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Maven搭建Spring+SpringMVC+Mybatis+ehcache项目]]></title>
    <url>%2F2015%2F10%2F18%2Fbuild-an-maven-spring-mybatis-ehcache-web-project%2F</url>
    <content type="text"><![CDATA[搭建Spring不用说肯定是必须的，前端使用SpringMVC 而不使用Struts2是因为SpringMVC的效率要比struts2要高很多，虽然struts2有丰富的标签可以使用，使用Mybatis是因为以后项目要做报表模块，Mybatis使用SQL Mapping的方式很容易操作数据库。 这里我们使用intellij idea来做我们的开发工具，废话不多说，开干。框架的版本是 Spring 3.2.8.RELEASESpring MVC 3.2.8.RELEASEmybatis 3.2.8 创建Maven Web项目（略）本项目中用的maven是 3.3.3版本的，要求jdk版本是1.7之后的 在pom.xml中加入项目依赖的jar包项目包依赖关系如下： pom文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;dependencies&gt; &lt;!-- Spring MVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Logging with SLF4J &amp; Log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis &amp; mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.0.0.m3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--Test--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 添加日志的支持日志我们使用slf4j，并用log4j来实现SLF4J不同于其他日志类库，与其它有很大的不同。SLF4J(Simple logging Facade for Java)不是一个真正的日志实现，而是一个抽象层（ abstraction layer），它允许你在后台使用任意一个日志类库。SLF4J还有很多优点，具体可以参考 http://javarevisited.blogspot.com/2013/08/why-use-sl4j-over-log4j-for-logging-in.html日志的实现类还是用熟悉的log4j，先要在项目的pom.xml文件中加入日志的支持 123456&lt;!-- Logging with SLF4J &amp; Log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt; 配置很简单,log4j的详细配置可以参考log4j官网 log4j.properties 12345678910111213log4j.rootLogger=INFO,Console,Filelog4j.appender.Console=org.apache.log4j.ConsoleAppenderlog4j.appender.Console.Threshold = DEBUGlog4j.appender.Console.layout=org.apache.log4j.PatternLayoutlog4j.appender.Console.layout.ConversionPattern=%d %p [%c] - %m%nlog4j.appender.A2=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.A2.File=$&#123;catalina.home&#125;/logs/log4j.appender.A2.Append=falselog4j.appender.A2.DatePattern='-'yyyy-MM-dd'.log'log4j.appender.A2.layout=org.apache.log4j.PatternLayoutlog4j.appender.A2.layout.ConversionPattern=%d %p [%c] - %m%n 整合Spring+Mybatis把Spring和Mybatis的jar包都引入之后就可以整合这两个框架了先看下项目的相关配置文件其中gererator.properties和generatorConfig.xml是用来根据数据库自动生成mapper接口，实体，以及映射文件的mybatis-config是mybatis的一些映射的相关配置，比如mapper，cache等spring-mybatis是自动扫描，自动装配mapper以及datasource，sqlSessionFactory等配置 这些会在接下来详细说明 JDBC配置文件1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root 创建spring-mybatis.xml创建spring-mybatis.xml来配置mybatis的一些信息，主要是数据源、事务、自动扫描、自动注入等功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!-- enable component scanning --&gt; &lt;context:component-scan base-package="com.zeusjava" /&gt; &lt;!-- enable autowire --&gt; &lt;context:annotation-config /&gt; &lt;!-- enable transaction demarcation with annotations --&gt; &lt;tx:annotation-driven /&gt; &lt;!-- 读取mysql jdbc的配置--&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt; &lt;/bean&gt; &lt;!-- 配置数据源，从上面配置文件读取--&gt; &lt;!-- 数据源 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;jdbc.initialSize&#125;" /&gt; &lt;property name="maxActive" value="$&#123;jdbc.maxActive&#125;" /&gt; &lt;property name="maxIdle" value="$&#123;jdbc.maxIdle&#125;" /&gt; &lt;property name="defaultAutoCommit" value="$&#123;jdbc.defaultAutoCommit&#125;" /&gt; &lt;property name="removeAbandoned" value="true" /&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;jdbc.removeAbandonedTimeout&#125;" /&gt; &lt;property name="logAbandoned" value="$&#123;jdbc.logAbandoned&#125;" /&gt; &lt;!--主动检测连接池是否有效--&gt; &lt;property name="testWhileIdle" value="$&#123;jdbc.testWhileIdle&#125;" /&gt; &lt;property name="validationQuery" value="$&#123;jdbc.validationQuery&#125;" /&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;jdbc.timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;property name="numTestsPerEvictionRun" value="$&#123;jdbc.numTestsPerEvictionRun&#125;" /&gt; &lt;/bean&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 配置扫描Domain的包路径 --&gt; &lt;property name="typeAliasesPackage" value="com.zeusjava.kernel.entity"/&gt; &lt;!-- 配置mybatis配置文件的位置 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"/&gt; &lt;!-- 配置扫描Mapper XML的位置 --&gt; &lt;property name="mapperLocations" value="classpath*:com/zeusjava/kernel/mapper/*.xml"/&gt; &lt;/bean&gt; &lt;!-- 配置扫描Mapper接口的包路径 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zeusjava.kernel.dao"/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建数据库表12345678910 CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(40) NOT NULL, `password` varchar(255) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; insert into `user`(`id`,`user_name`,`password`) values (1,'赵宏轩','123456'); 创建User的Mapping映射文件,User实体和Mapper接口在pom.xml中添加mybatis-generator-maven-plugin插件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 &lt;build&gt; &lt;finalName&gt;HelloSSM&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;```#### 在maven项目下的src/main/resources 目录下建立名为 generatorConfig.xml的配置文件以及和generator有关的属性文件，作为mybatis-generator-maven-plugin 插件的执行目标![目录结构](http://i13.tietuku.com/274205a36b4c55d5.png) generatorConfig.xml ```xml &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--导入属性配置 --&gt; &lt;properties resource="generator.properties"&gt;&lt;/properties&gt; &lt;!--指定特定数据库的jdbc驱动jar包的位置 --&gt; &lt;classPathEntry location="$&#123;jdbc.driverLocation&#125;"/&gt; &lt;context id="default" targetRuntime="MyBatis3"&gt; &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass="$&#123;jdbc.driverClassName&#125;" connectionURL="$&#123;jdbc.url&#125;" userId="$&#123;jdbc.username&#125;" password="$&#123;jdbc.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="com.zeusjava.kernel.entity" targetProject="src/main/java"&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name="constructorBased" value="true"/&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name="immutable" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;sqlMapGenerator targetPackage="com.zeusjava.kernel.mapper" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator targetPackage="com.zeusjava.kernel.dao" targetProject="src/main/java" type="MIXEDMAPPER"&gt; &lt;property name="enableSubPackages" value=""/&gt; &lt;property name="exampleMethodVisibility" value=""/&gt; &lt;property name="methodNameCalculator" value=""/&gt; &lt;property name="rootInterface" value=""/&gt; &lt;/javaClientGenerator&gt; &lt;table tableName="user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 还有与之相关联的generator.properties文件 12345jdbc.driverLocation=D:\\idea\\maven\\mysql\\mysql-connector-java\\5.1.29\\mysql-connector-java-5.1.29.jarjdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root 在Intellij IDEA添加一个“Run运行”选项，使用maven运行mybatis-generator-maven-plugin插件1).点击Run,选择Edit Configurations2).点击左上角的+，选择maven3).输入name,选择Working directory,Command line 填上mybatis-generator:generate -e 点击运行查看结果运行插件控制台如果打印build Success 就说明成功了会在指定目录产生三个文件，分别是实体，Mapper接口，Mapping配置文件 创建mybatis-config.xml配置文件12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name="cacheEnabled" value="false"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;setting name="localCacheScope" value="STATEMENT"/&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;setting name="defaultStatementTimeout" value="25000"/&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;!-- 是否使用插入数据后自增主键的值，需要配合keyProperty使用 --&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias alias="User" type="com.zeusjava.kernel.entity.User" /&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;!--&lt;mapper resource="com/zeusjava/kernel/mapper/UserMapper.xml"/&gt;--&gt; &lt;!--&lt;mapper class="com.zeusjava.kernel.dao.UserMapper"/&gt;--&gt; &lt;!--&lt;mapper url="file:///D:/idea/HelloSSM/src/main/java/com/zeusjava/kernel/mapper/UserMapper.xml"/&gt;--&gt; &lt;package name="com.zeusjava.kernel.dao"/&gt; &lt;!--&lt;mapper class="com.zeusjava.kernel.dao.UserMapper"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 其中最后的mapper有四种配置方式，但是，在我的电脑上只有使用url的方式才行，不知道是怎么回事，待查询。 建立Service接口和实现类IUserService.java代码如下 12345678910package com.zeusjava.kernel.service;import com.zeusjava.kernel.entity.User;/** * Created by LittleXuan on 2015/10/17. */public interface IUserService &#123; public User getUserById(int userId);&#125; UserServiceImpl.java的代码如下 123456789101112131415161718192021222324package com.zeusjava.kernel.service.impl;import com.zeusjava.kernel.dao.UserMapper;import com.zeusjava.kernel.entity.User;import com.zeusjava.kernel.service.IUserService;import org.springframework.stereotype.Repository;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * Created by LittleXuan on 2015/10/17. */@Service("userService")public class IUserServiceImpl implements IUserService &#123; @Resource private UserMapper userMapper; @Override public User getUserById(int userId) &#123; return this.userMapper.selectUserByUserId(userId); &#125;&#125; 建立测试类1234567891011121314151617181920212223242526272829import com.zeusjava.kernel.entity.User;import com.zeusjava.kernel.service.IUserService;import org.junit.Test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;/** * Created by LittleXuan on 2015/10/17. */@RunWith(SpringJUnit4ClassRunner.class) //表示继承了SpringJUnit4ClassRunner类@ContextConfiguration(locations = &#123;"classpath:conf/spring/beans-mybatis.xml"&#125;)public class SSMTest &#123; private static Logger logger = LoggerFactory.getLogger(SSMTest.class); @Resource private IUserService userService = null; @Test public void test1() &#123; User user = userService.getUserById(1); logger.info("姓名："+user.getUserName()); &#125;&#125; 运行单元测试，结果如下，说明spring和mybatis的整合已经完成。 和SpringMVC整合和Spring MVC的整合就简单的多了，只需要添加一个Spring MVC配置文件，和配置一下Web.xml就行了，我在前面的博客写过一篇文章，请戳 Maven整合Spring MVC搭建笔记-ZeusJava Blog ###1.配置Spring MVC 配置文件zeusjava-servlet.xml在配置文件里主要配置 自动扫描控制器，视图解析器，注解 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd "&gt; &lt;!-- 激活利用注解进行装配 --&gt; &lt;context:annotation-config /&gt; &lt;!-- ① ：对 web 包中的所有类进行扫描，以完成 Bean 创建和自动依赖注入的功能 --&gt; &lt;context:component-scan base-package="com.zeusjava.web.controller"/&gt; &lt;!-- ② ：启动 Spring MVC 的注解功能，完成请求和注解 POJO 的映射 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"/&gt; &lt;!-- ③ ：对模型视图名称的解析，即在模型视图名称添加前后缀 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/WEB-INF/jsp/" p:suffix=".jsp"/&gt; &lt;/beans&gt; 配置web.xml在web.xml里配置Spring MVC的DispatcherServlet和mybatis的配置文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;display-name&gt;HelloSSM&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring MVC servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 在WEB_INF/jsp建立一个简单的测试页面user.jsp12345678&lt;%@ page language="java" pageEncoding="UTF-8"%&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;用户ID为$&#123;user.id&#125;的用户详情&lt;/h1&gt;ID：$&#123;user.id&#125;姓名:$&#123;user.userName&#125;&lt;/body&gt;&lt;/html&gt; 建立User控制器通过url传入一个id，解析这个id然后查询数据库，得到User对象放入jsp页面显示。 1234567891011121314151617181920212223242526272829303132333435package com.zeusjava.web.controller;/** * Created by LittleXuan on 2015/10/18. */import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import com.zeusjava.kernel.entity.User;import com.zeusjava.kernel.service.IUserService;import org.apache.commons.lang.StringUtils;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller@RequestMapping("/user")public class UserController &#123; @Resource private IUserService userService; @RequestMapping(value="/userInfo/&#123;id&#125;", method= RequestMethod.GET) public String toIndex(HttpServletRequest request, Model model,@PathVariable("id") String id) &#123; if(StringUtils.isEmpty(id))&#123; throw new IllegalArgumentException("id不能为空"); &#125; int userId = Integer.parseInt(id); User user = this.userService.getUserById(userId); model.addAttribute("user", user); return "user"; &#125;&#125; 添加tomcat服务器并部署war包File-Project Structure点击Artifacts一栏点击+，选择Web-Application-Exploded然后选择from maven选中本项目Web Application Exploded是没有压缩的war包，相当于文件夹Web Application Achieved是雅俗后的war包 intellij会自动帮我们生成一个war包 点击Run-Run Configurations点击+选择tomcat server-&gt;local 点击Configure 点击Deployment选项卡，点击+号，选择一个artifact，就是第二部的war包 OK启动服务器在任务栏输入http://localhost:8081/HelloSSM/user/userInfo/1,回车，结果如下：一个简单的SSM项目环境就搭建好了。 和ehcache的整合Ehcache是Hibernate的默认的cache，但是mybatis中需要自己集成，在Mybatis中使用会大大增加性能，下面开始整合mybatis和Ehcache 使用首先要把需要的jar包依赖加入pom中12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.0.0.m3&lt;/version&gt;&lt;/dependency&gt; 在Resource中添加一个ehcache.xml的配置文件123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd" updateCheck="false"&gt; &lt;diskStore path="java.io.tmpdir" /&gt; &lt;defaultCache eternal="false" maxElementsInMemory="1000" overflowToDisk="false" diskPersistent="false" timeToIdleSeconds="0" timeToLiveSeconds="600" memoryStoreEvictionPolicy="LRU" /&gt; &lt;cache name="testCache" eternal="false" maxElementsInMemory="100" overflowToDisk="false" diskPersistent="false" timeToIdleSeconds="0" timeToLiveSeconds="300" memoryStoreEvictionPolicy="LRU" /&gt;&lt;/ehcache&gt; 说明： name：Cache的唯一标识 maxElementsInMemory：内存中最大缓存对象数 maxElementsOnDisk：磁盘中最大缓存对象数，若是0表示无穷大 eternal：Element是否永久有效，一但设置了，timeout将不起作用 overflowToDisk：配置此属性，当内存中Element数量达到maxElementsInMemory时，Ehcache将会Element写到磁盘中 timeToIdleSeconds：设置Element在失效前的允许闲置时间。仅当element不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大 timeToLiveSeconds：设置Element在失效前允许存活时间。最大时间介于创建时间和失效时间之间。仅当element不是永久有效时使用，默认是0.，也就是element存活时间无穷大 diskPersistent：是否缓存虚拟机重启期数据 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒 diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用） 在spring-mybatis.xml中加入chache配置1234&lt;!-- 使用ehcache缓存 --&gt;&lt;bean id="ehCacheManager" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt; &lt;property name="configLocation" value="classpath:ehcache.xml" /&gt;&lt;/bean&gt; 在mapper.xml中配置cache1234567&lt;cache type="org.mybatis.caches.ehcache.LoggingEhcache" &gt; &lt;property name="timeToIdleSeconds" value="3600"/&gt; &lt;property name="timeToLiveSeconds" value="3600"/&gt; &lt;property name="maxEntriesLocalHeap" value="1000"/&gt; &lt;property name="maxEntriesLocalDisk" value="10000000"/&gt; &lt;property name="memoryStoreEvictionPolicy" value="LRU"/&gt; &lt;/cache&gt; type是使用的cache类型，LoggingEhcache会记录下日志，如果不需要日志的话可以使用EhcacheCache这样配置之后，所以的操作都会执行缓存，如果有的操作不需要的话，可以在sql配置里将useCache设置为false 123456789@Select(&#123; "select", "id, user_name, password", "from user", "where id = #&#123;id,jdbcType=INTEGER&#125;"&#125;)@Options(useCache = false,timeout = 10000,flushCache = false)@ResultMap("BaseResultMap")User selectByPrimaryKey(Integer id); 测试性能测试代码 12345678@Test public void test1() &#123; long beginTime=System.nanoTime(); User user = userService.getUserById(1); long endTime=System.nanoTime(); System.out.println("查询时间 :" + (endTime-beginTime)+"ns"); logger.info("姓名："+user.getUserName()); &#125; 第一次把useCache设置为false 第二次把useCache设置为true 两次执行的时间差了大约0.4秒 整个项目已经放到github上了，有需要的可以前往HelloSSM查看， 不懂的地方欢迎探讨…]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>ehcache</tag>
        <tag>spring</tag>
        <tag>maven</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种遍历Map的方法]]></title>
    <url>%2F2015%2F10%2F17%2Fthree-method-to-iterate-a-map%2F</url>
    <content type="text"><![CDATA[昨天在使用KeySet的方式遍历一个HashMap时，然后试图remove掉其中的一个元素的时候，Java虚拟机抛出了一个java.util.ConcurrentModificationException的异常。搜集了一下java中遍历一个Map的几种方法，主要有以下三种，只有使用使用Iterator遍历的时候才可以移除元素。其他的两种操作都有可能报ConcurrentModificationException的异常。然后顺便整理了一下遍历Map的几种方法。参考了StackOverFlow上的这个问题,请戳Iterate through a HashMap 方法1:使用For-Each循环迭代entrySet这种方法应该是使用的最多的了，一般需要使用Map的key和value时候使用这个方法 12345Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());&#125; For-Each是在Java 5 中被引进的，所以这种方法只能在JDK5之后才能使用，而且使用之前要判断map是否为null。 方法2:通过迭代keys或者values来遍历Map的keySet和valuesMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();如果只需要遍历key或者value的时候可以直接遍历keySet或者values来取代entrySet 123456789//仅仅遍历keyfor (Integer key : map.keySet()) &#123; System.out.println("Key = " + key);&#125;//仅仅遍历valuesfor (Integer value : map.values()) &#123; System.out.println("Value = " + value);&#125; 这种方法比使用entrySet的方式要快，而且要更简洁。 ####PS.当然也完全可以，遍历完keySet之后只用get()方法查找到对应的value来达到遍历key-value的目的 12345Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();for (Integer key : map.keySet()) &#123; Integer value = map.get(key); System.out.println("Key = " + key + ", Value = " + value);&#125; 这种方法貌似比第一种要简洁，但是…注意，重要的话说三遍 这种方法非常耗时间 这种方法非常耗时间 这种方法非常耗时间 这种方法相比第一种来说要慢20%~200%，所以使用这种方法来遍历key-value的方式应该被避免使用。 使用Iterator遍历123456789101112131415161718//使用泛型:Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();while (entries.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()); it.remove();//避免 ConcurrentModificationException&#125;//不使用泛型:Map map = new HashMap();Iterator it = map.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry entry = (Map.Entry) it.next(); Integer key = (Integer)entry.getKey(); Integer value = (Integer)entry.getValue(); System.out.println("Key = " + key + ", Value = " + value); it.remove();//避免 ConcurrentModificationException&#125; 这种方法看起来很多余，但是它也有自己的优点 这是仅有的一种可以遍历以前Java版本中Map的方法（For-Each） 这是仅有的一种可以在你遍历期间移除元素的方法,这种方式解决了文章开头的ConcurrentModificationException的错误。结论 如果仅仅需要遍历key或者value可以使用方法2 如果需要在老版本（java5之前的版本）或者要在遍历过程中删除元素时请使用方法3 其他情况下使用方法1]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JDK动态代理和cglib动态代理]]></title>
    <url>%2F2015%2F10%2F13%2Fjdk-dynamic-agent-and-cglib%2F</url>
    <content type="text"><![CDATA[一晃眼，国庆节已经过去了，时间到了10月中旬了，总是感觉时间不够用，想多看点书，多写点代码，在点滴中积淀属于自己的知识系统。 闲言少叙，先来说一下什么是代理模式，我们去一个新的地方总是要先找地方住，但是我们人生地不熟的掌握的资源不多，这时候一般会找中介，中介对房源很熟悉，很快就能为你找到合适的房子，这时候，中介就是一个代理,你就相当于是一个委托方。 下面是设计模式中的代理： 代理模式代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。 按照代理的创建时期，代理类可以分为两种： 静态代理由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。 动态代理在程序运行时，运用反射机制动态创建而成。 动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。java.lang.reflect 包中的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。 动态代理有很多种，先看第一种，JDK动态代理 JDK动态代理先来看下JDK源码中InvocationHandler中invoke()方法 12public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; JDK源码中Proxy类的代码： 123456789101112131415161718192021222324252627282930public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; if (h == null) &#123; throw new NullPointerException(); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass(loader, interfaces); /* * Invoke its constructor with the designated invocation handler. */ try &#123; Constructor cons = cl.getConstructor(constructorParams); return cons.newInstance(new Object[] &#123; h &#125;); &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString()); &#125; catch (IllegalAccessException e) &#123; throw new InternalError(e.toString()); &#125; catch (InstantiationException e) &#123; throw new InternalError(e.toString()); &#125; catch (InvocationTargetException e) &#123; throw new InternalError(e.toString()); &#125;&#125; 参数说明：ClassLoader loader：类加载器 Class&lt;?&gt;[] interfaces：得到全部的接口 InvocationHandler h：得到InvocationHandler接口的子类实例 PS:类加载器在Proxy类中的newProxyInstance（）方法中需要一个ClassLoader类的实例，ClassLoader实际上对应的是类加载器，在Java中主要有一下三种类加载器: Booststrap ClassLoader：此加载器采用C++编写，一般开发中是看不到的； Extendsion ClassLoader：用来进行扩展类的加载，一般对应的是jre\lib\ext目录中的类; AppClassLoader：(默认)加载classpath指定的类，是最常使用的是一种加载器。 JDK动态代理实现步骤实现InvocationHandler接口获得代理对象123public Object getInstance(Object target)&#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);&#125; 回调函数12345678@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; System.out.println("jdk 动态代理 begin..."); result = method.invoke(target,args); System.out.println("jdk 动态代理 end..."); return result;&#125; JDK动态代理缺点： 只能对实现了接口的类进行，没有实现接口的类不能使用JDK动态代理。 cglib动态代理JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。cglib实现动态代理的方法和JDK动态代理类似 实现MethodInterceptor接口获得代理对象123456789public Object getInstance(Object target)&#123; this.target = target; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(this.target.getClass()); //设置回调方法 enhancer.setCallback(this); //创建代理对象 return enhancer.create();&#125; 设置回调方法1234567@Overridepublic Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("UserFacadeProxy.intercept begin"); methodProxy.invokeSuper(o,objects); System.out.println("UserFacadeProxy.intercept end"); return null;&#125; Spring AOP原理java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。SpringAOP动态代理策略是： 1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>cglib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信内置浏览器js/css缓存解决办法]]></title>
    <url>%2F2015%2F09%2F28%2Fstatic-resource-realtime-load%2F</url>
    <content type="text"><![CDATA[情况是这样的，最近在微信公众号的后台更改js代码提交之后，过了很长时间，代码都没有起效，于是清除服务器缓存，清除微信缓存，重新关注公众号，重启手机都用了还是不行，但是用同事的手机（之前没有关注该公众号）js代码就起效了，后来才发现是微信内置浏览器缓存的问题。 解决方法在jsp页面中通过给js文件传递一个随机数或者时间戳在这里用随机数 1&lt;script type="text/javascript" src="/js/weixin.js?r=&lt;%=Math.random()%&gt;"&gt;&lt;/script&gt; 由于每次加载该js文件，请求路径都是不一致的，所以服务器会认为是不同的请求所以会实时把最新的js文件同步到浏览器，就不怕浏览器缓存的问题了。]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js学习笔记（二）]]></title>
    <url>%2F2015%2F09%2F22%2Flearn-vue-js-2%2F</url>
    <content type="text"><![CDATA[继续上一篇文章，中间耽误了一个多星期，去面试和复习以前的代码，继续愉快的的vue.js学习之旅 :)… 列表渲染vue.js的v-repeat指令用来根据相对应的ViewModel的对象数组来渲染列表。 简单示例html代码： 12345&lt;ul id="demo"&gt; &lt;li v-repeat="items" class="item-&#123;&#123;$index&#125;&#125;"&gt; &#123;&#123;$index&#125;&#125; : &#123;&#123;parentMsg&#125;&#125; &#123;&#123;childMsg&#125;&#125; &lt;/li&gt;&lt;/ul&gt; js代码： 12345678910var demo = new Vue(&#123; el: '#demo', data: &#123; parentMsg: '你好', items: [ &#123; childMsg: '赵' &#125;, &#123; childMsg: '宏轩' &#125; ] &#125;&#125;) 这些子实例继承父实例的数据作用域，因此在重复的模板元素中你既可以访问子实例的属性，也可以访问父实例的属性。还可以通过$index属性来获取当前实例对应的数组索引。 块级重复&lt;template&gt;标签用来重复循环一个包含多个节点的块 123456&lt;ul&gt; &lt;template v-repeat="list"&gt; &lt;li&gt;&#123;&#123;msg&#125;&#125;&lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 简单值数组简单值 (primitive value) 是字符串、数字、boolean 等并非对象的值。对于包含简单值的数组，可用$value直接访问值: 12345&lt;ul id="tags"&gt; &lt;li v-repeat="tags"&gt; &#123;&#123;$value&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456new Vue(&#123;el:'tags',data:&#123; tags:['java','sql','c++']&#125;&#125;) 使用别名如果想要访问实例对象的属性，可以通过in关键字来获得repeat对象的单个对象，有点类似于java中的for-each 12345&lt;ul id="users"&gt; &lt;li v-repeat="user in users"&gt; &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.email&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789new Vue(&#123; el: '#users', data: &#123; users: [ &#123; name: '赵小轩', email: 'hongxuanzhao@gmail.com' &#125;, &#123; name: '窦小娜', email: 'xiaonadou@gmail.com' &#125; ] &#125;&#125;) 遍历对象使用使用v-repeat遍历一个对象的所有属性，每个重复的实例会有一个特殊的属性$key。对于简单值，你也可以象访问数组中的简单值那样使用$value属性。 12345&lt;ul id="repeat-object"&gt; &lt;li v-repeat="primitiveValues"&gt;&#123;&#123;$key&#125;&#125; : &#123;&#123;$value&#125;&#125;&lt;/li&gt; &lt;li&gt;===&lt;/li&gt; &lt;li v-repeat="objectValues"&gt;&#123;&#123;$key&#125;&#125; : &#123;&#123;msg&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 123456789101112131415161718new Vue(&#123; el: '#repeat-object', data: &#123; primitiveValues: &#123; FirstName: 'John', LastName: 'Doe', Age: 30 &#125;, objectValues: &#123; one: &#123; msg: 'Hello' &#125;, two: &#123; msg: 'Bye' &#125; &#125; &#125;&#125;) 迭代值域v-repeat可以接收一个整数，然后重复显示模版多次 123&lt;div id="range"&gt; &lt;div v-repeat="val"&gt;Hi! &#123;&#123;$index&#125;&#125;&lt;/div&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#range', data: &#123; val: 3 &#125;&#125;); 数组过滤器Vue有两个内置的过滤器来过滤或者排序数据，分别是：filterBy和orderBy。 filterBy语法： filterBy searchKey [in dataKey...] 返回原数组过滤后的结果。searchKey 参数是当前ViewModel 的一个属性名，这个属性的值会被用作查找的目标。in关键字指定具体要在哪个属性中进行查找。用法： 1.不使用in关键字1234&lt;input v-model="searchText"&gt;&lt;ul&gt; &lt;li v-repeat="users | filterBy searchText"&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 这个过滤器会遍历整个users数组每个元素的每个属性值来匹配searchText的内容比如如果一个元素为{name:&#39;赵宏轩&#39;,tel:&#39;021-111111&#39;},searchText的值为021,那么这条数据就是合法的数据，不会被过滤器过滤掉。 2.使用in关键字1234&lt;input v-model="searchText"&gt;&lt;ul&gt; &lt;li v-repeat="user in users | filterBy searchText in 'name'"&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 和上一个例子数据一样，但是如果searchText的值还是021的话，那么这条数据就会被过滤掉。因为过滤的内容限定在 name属性中，如果searchText的值为赵的话，这个元素就不会被过滤掉。 OrderBy语法： orderBy sortKey [reverseKey]. orderBy用于返回原数组排序后的结果。sortKey参数是当前ViewModel的一个属性名。这个属性的值表示用来排序的键名.reverseKey参数也是当前ViewModel的一个属性名，如果这个属性值为真则数组会被倒序排列。可以使用引号来表示字面量的排序键名。使用 -1 来表示字面量的 reverse 参数。 语法： orderBy sortKey [reverseKey]. 用法： 123&lt;ul&gt; &lt;li v-repeat="user in users | orderBy field reverse"&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 1234567new Vue(&#123; /* ... */ data: &#123; field: 'name', reverse: false &#125;&#125;)]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven整合Spring MVC搭建笔记]]></title>
    <url>%2F2015%2F09%2F12%2Fmaven-springmvc-demo%2F</url>
    <content type="text"><![CDATA[Maven是一个有效的项目管理构建工具，可以帮我们管理项目的生命周期，和项目中依赖的jar包，下面使用Maven来整合Spring来实现一个简单的登录功能。 在intellij中新建一个maven webapp项目，叫做HelloSpring 在pom.xml中添加Spring包的依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;properties&gt; &lt;org.springframework.version&gt;3.2.2.RELEASE&lt;/org.springframework.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring mvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--data source --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Maven中Spring jar包的依赖关系在intellij idea中打开pom.xml文件，右键Diagrams选择Show Dependencies就会出现Maven项目中包的依赖关系 web.xml配置web.xml需要配置DispatcherServlet和listener 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;display-name&gt;Hello Spring&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;Spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; spring-servlet.xml的配置在这里将Spring MVC配置文件单独从applicationContext.xml中抽取出来，在spring-servlet.xml中配置视图解析器、拦截器、自动扫描等信息 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!--扫描自动依赖注入的包名 --&gt; &lt;context:component-scan base-package="com.zeusjava.controller"/&gt; &lt;!-- 默认的注解映射的支持 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!--视图解释器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; 需要注意的是schemaLocation 的设置一定要正确，一个schema对应一个xsd文件，如果缺少的话，就会报通配符的匹配很全面, 但无法找到元素 ‘context:component-scan’ 的声明的错误~教训啊 applicationContext.xml配置由于我们把Spring MVC的配置文件spring-servlet.xml提取出来了，如果需要配置事务、数据源等可以在applicationContent中配置，这个简单的demo还不需要，所以先空着。 Controller代码实现 12345678910111213141516171819202122232425262728293031323334package com.zeusjava.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Created by LittleXuan on 2015/9/12. */@Controller@RequestMapping("account")public class AccountController &#123; @RequestMapping(value="/login", method= RequestMethod.GET) public String login(HttpServletRequest request ,HttpServletResponse response) &#123; return "account/login"; &#125; @RequestMapping(value="/login", method= RequestMethod.POST) public ModelAndView loginResponse(@RequestParam("username") String username,@RequestParam("password") String password,HttpServletRequest request) &#123; ModelAndView m =new ModelAndView(); if(username.equals("zhaohongxuan")&amp;&amp;password.equals("123"))&#123; m.setViewName("index"); return m; &#125; m.setViewName("error"); return m; &#125;&#125; jsp代码123456789101112131415161718192021&lt;%-- Created by IntelliJ IDEA. User: LittleXuan Date: 2015/9/12 Time: 14:55 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="/account/login" method="post"&gt; 用户名：&lt;input type="text" name="username" &gt;&lt;br/&gt; 密码：&lt;input type="password" name="password"&gt;&lt;br/&gt; &lt;input type="submit" value="登录"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 启动项目测试]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 整合Spring]]></title>
    <url>%2F2015%2F09%2F11%2Fredis-java-spring%2F</url>
    <content type="text"><![CDATA[Redis是一种性能非常高效的Key-Value数据库，在企业项目开发中应用广泛，因为一直用Spring，所以决定使用Spring支持的spring-data-redis,java中Redis有多种客户端，Spring推荐的是Jedis，这篇文章就是基于Jedis的。 SDR(Spring Data Redis)简介SDR(Spring Data Redis)支持低层次的通过连接器connector连接到Redis，支持高层次的友好的模板类RedisTemplate,RedisTemplate是建立在低级别的connection基础之上。RedisConnection接收或返回字节数组需要自身处理连接，比如关闭连接，而RedisTemplate负责处理串行化和反串行化，并且管理对连接进行管理。RedisTemplate提供操作视图，比如(Bound)ValueOperations,(Bound)ListOperations,(Bound)SetOperations,(Bound)ZSetOperations,(Bound)HashOperations。RedisTemplate是线程安全的，能够用于多个实例中。RedisTemplate默认选择java-based串行化,也可以切换为其它的串行化方式，或者设置enabledDefaultSerializer为false或者设置串行化器为null，则RedisTemplate用raw byte arrays表示数据。SDR连接到redis通过RedisConnectionFactory来获得有效的RedisConnection。RedisConnection负责建立和处理和redis后端通信。RedisConnection提供getNativeconnection返回用来通信的底层connection。 Maven的pom.xml文件配置在dependencies中添加两个依赖，分别是spring-data-redis和jedis 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; Properties文件中配置Redis的基本参数12345678# Redis configredis.host=localhostredis.port=6379redis.password=redis.maxIdle=300redis.maxActive=600redis.maxWait=1000redis.testOnBorrow=true 配置applicationContext.xml在applicationContext.xmlS中配置jedisConnFactory和jedisTemplate，加载Properties的各个属性 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.zeusjava.osf.model" /&gt; &lt;context:component-scan base-package="com.zeusjava.osf.dao.impl" /&gt; &lt;context:component-scan base-package="com.zeusjava.osf.service" /&gt; &lt;context:component-scan base-package="com.zeusjava.osf.util" /&gt; &lt;context:property-placeholder location="classpath:spring/property.properties"/&gt; &lt;bean id="jedisConnFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" p:usePool="true" p:hostName="$&#123;redis.host&#125;" p:port="$&#123;redis.port&#125;" p:password="$&#123;redis.password&#125;"/&gt; &lt;!-- redis template definition --&gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" p:connectionFactory-ref="jedisConnFactory"&gt; &lt;property name="keySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="hashKeySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" p:dataSource-ref="dataSource"/&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; &lt;/beans&gt; 在java类中使用Redis进行增删改查下面是一个简单的查询的例子 123456789101112131415161718@Repository("userDao")public class UserDAOImpl implements UserDAO&#123; @Autowired @Qualifier("redisTemplate") private RedisTemplate&lt;String, String&gt; redisTemplate; @Resource(name="redisTemplate") private HashOperations&lt;String, String, Object&gt; mapOps; public User getUserByID(int id) &#123; String key = "user:"+id; Object obj = mapOps.get("user",key); User user = (User) obj; return user; &#125;&#125;]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js学习笔记（一）]]></title>
    <url>%2F2015%2F09%2F09%2Flearn-vue-js%2F</url>
    <content type="text"><![CDATA[简介Vue.js 是一个用于创建 web 交互界面的库。 从技术角度讲，Vue.js专注于MVVM模型的ViewModel层。它通过双向数据绑定把View层和 Model 层连接了起来。实际的DOM封装和输出格式都被抽象为了Directives和Filters。 从哲学角度讲，Vue 希望通过一个尽量简单的 API 来提供响应式的数据绑定和可组合、复用的视图组件。它不是一个大而全的框架——它只是一个简单灵活的视图层。您可以独立使用它快速开发原型、也可以混合别的库做更多的事情。它同时和诸如 Firebase 这一类的 BaaS 服务有着天然的契合度。 Vue.js 的 API 设计深受AngularJS、KnockoutJS、Ractive.js 和 Rivets.js 的影响。尽管有不少相似之处，但我们相信 Vue.js 能够在简约和功能之间的微妙平衡中体现出其独有的价值。 ViewModelViewModel在vue.js中同步Model和View的对象，在vue.js中，每个vue.js实例都是一个ViewModel它们是通过构造函数 Vue或者其子类被创建出来的 1var vm =new Vue(&#123;&#125;); 视图(View)View是被Vue实例管理的DOM节点 1vm.$el Vue.js 使用基于 DOM 的模板。每个 Vue 实例都关联着一个相应的 DOM 元素。当一个 Vue 实例被创建时，它会递归遍历根元素的所有子结点，同时完成必要的数据绑定。当这个视图被编译之后，它就会自动响应数据的变化。 当数据发生变化时，视图将会自动触发更新。这些更新的粒度精确到一个文字节点。同时为了更好的性能，这些更新是批量异步执行的。 模型(Model)1vm.$data Vue.js中的模型就是普通的javascript对象。一旦某对象被作为 Vue 实例中的数据，它就成为一个 “响应式” 的对象了。你可以操作它们的属性，同时正在观察它的 Vue 实例也会收到提示。 指令(Directives)Vue.js的指令是带有特殊前缀v-的HTML特性，可以让Vue.js对DOM做各种处理。 简单示例1&lt;div v-text ='name'&gt; &lt;/div&gt; 这里的前缀是默认的 v-。指令的ID 是 text，表达式是 name。这个指令告诉 Vue.js， 当 Vue 实例的 name 属性改变时，更新该 div 元素的 textContent。Directives 可以封装任何 DOM 操作。比如v-attr 会操作一个元素的特性；v-repeat 会基于数组来复制一个元素；v-on 会绑定事件等 内联表达式1&lt;div v-text="'hello ' + user.firstName + ' ' + user.lastName"&gt;&lt;/div&gt; 这里我们使用了一个计算表达式 (computed expression)，而不仅仅是简单的属性名。Vue.js 会自动跟踪表达式中依赖的属性并在这些依赖发生变化的时候触发指令更新。同时，因为有异步批处理更新机制，哪怕多个依赖同时变化，表达式也只会触发一次。需要注意的是Vue.js 把内联表达式限制为一条语句。如果需要绑定更复杂的操作，可以使用计算属性。 参数1&lt;div v-on="click : clickHandler"&gt;&lt;/div&gt; 有些指令需要在路径或表达式前加一个参数。在这个例子中click参数代表了我们希望v-on 指令监听到点击事件之后调用该 ViewModel 实例的 clickHandler 方法。 多重指令从句你可以在同一个特性里多次绑定同一个指令。这些绑定用逗号分隔，它们在底层被分解为多个指令实例进行绑定。 字面量指令有些指令不会创建数据绑定——它们的值只是一个字符串字面量。比如 v-ref 指令： 1&lt;my-component v-ref="some-string-id"&gt;&lt;/my-component&gt; 这里的 some-string-id 并不是一个响应式的表达式 — Vue.js不会尝试去观测组件中的对应数据。 在有些情况下，你也可以使用 Mustache 风格绑定来使得字面量指令 反应化： 1&lt;div v-show="showMsg" v-transition="&#123;&#123;dynamicTransitionId&#125;&#125;"&gt;&lt;/div&gt; 但是，请注意只有v-transition 指令具有此特性。Mustache表达式在其他字面量指令中，例如 v-ref 和 v-el，只会被计算一次。它们在编译完成后将不会再响应数据的变化。 Mustache 风格绑定你也可以使用 mustache 风格的绑定，不管在文本中还是在属性中。它们在底层会被转换成 v-text 和 v-attr 的指令。比如： 1&lt;div id="person-&#123;&#123;id&#125;&#125;"&gt;Hello &#123;&#123;name&#125;&#125;!&lt;/div&gt; 过滤器(filter)示例过滤器是用于在更新视图之前处理原始值的函数,它们通过一个“管道”在指令或绑定中进行处理： 1&lt;div&gt;&#123;&#123;message | capitalize&#125;&#125;&lt;/div&gt; 这样在 div 的文本内容被更新之前，message 的值会先传给 capitalizie 函数处理。 参数一些过滤器是可以接受参数的。参数用空格分隔开： 12&lt;span&gt;&#123;&#123;order | pluralize 'st' 'nd' 'rd' 'th'&#125;&#125;&lt;/span&gt;&lt;input v-on="keyup: submitForm | key 'enter'"&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中使用DES对称加解密]]></title>
    <url>%2F2015%2F09%2F07%2Fjava-des-encrypt%2F</url>
    <content type="text"><![CDATA[DESDES(Data Encryption Standard),即数据加密算法。是IBM公司于1975年研究成功并公开发表的。DES算法的入口参数有三个:Key、Data、Mode。其中Key为8个字节共64位,是DES算法的工作密钥;Data也为8个字节64位,是要被加密或被解密的数据;Mode为DES的工作方式,有两种:加密或解密。 安卓端对请求Web服务器请求字符串进行加密加密公共方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.sz.kcygl.common.DESUtil;import java.security.Key;import java.security.SecureRandom;import java.security.spec.AlgorithmParameterSpec;import javax.crypto.Cipher;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import javax.crypto.spec.IvParameterSpec;import com.sun.org.apache.xml.internal.security.utils.Base64;public class DESUtil &#123; public static final String ALGORITHM_DES = "DES/CBC/PKCS5Padding"; /** * DES算法，加密 * * @param data * 待加密字符串 * @param key * 加密私钥，长度不能够小于8位 * @return 加密后的字节数组，一般结合Base64编码使用 * @throws CryptException * 异常 */ public static String encode(String key, String data) throws Exception &#123; return encode(key, data.getBytes()); &#125; /** * DES算法，加密 * * @param data * 待加密字符串 * @param key * 加密私钥，长度不能够小于8位 * @return 加密后的字节数组，一般结合Base64编码使用 * @throws CryptException * 异常 */ public static String encode(String key, byte[] data) throws Exception &#123; try &#123; DESKeySpec dks = new DESKeySpec(key.getBytes()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); // key的长度不能够小于8位字节 Key secretKey = keyFactory.generateSecret(dks); Cipher cipher = Cipher.getInstance(ALGORITHM_DES); IvParameterSpec iv = new IvParameterSpec("12345678".getBytes()); AlgorithmParameterSpec paramSpec = iv; cipher.init(Cipher.ENCRYPT_MODE, secretKey, paramSpec); byte[] bytes = cipher.doFinal(data); return Base64.encode(bytes); &#125; catch (Exception e) &#123; throw new Exception(e); &#125; &#125; /** * DES算法，解密 * * @param data * 待解密字符串 * @param key * 解密私钥，长度不能够小于8位 * @return 解密后的字节数组 * @throws Exception * 异常 */ public static byte[] decode(String key, byte[] data) throws Exception &#123; try &#123; SecureRandom sr = new SecureRandom(); DESKeySpec dks = new DESKeySpec(key.getBytes()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); // key的长度不能够小于8位字节 Key secretKey = keyFactory.generateSecret(dks); Cipher cipher = Cipher.getInstance(ALGORITHM_DES); IvParameterSpec iv = new IvParameterSpec("12345678".getBytes()); AlgorithmParameterSpec paramSpec = iv; cipher.init(Cipher.DECRYPT_MODE, secretKey, paramSpec); return cipher.doFinal(data); &#125; catch (Exception e) &#123; // e.printStackTrace(); throw new Exception(e); &#125; &#125; /** * 获取编码后的值 * * @param key * @param data * @return * @throws Exception * @throws Exception */ public static String decodeValue(String key, String data) throws Exception &#123; byte[] datas; String value = null; datas = decode(key, Base64.decode(data)); value = new String(datas); if (value.equals("")) &#123; throw new Exception(); &#125; return value; &#125;&#125; java后台服务器通过一个拦截器，拦截掉所有需要拦截的路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.sz.kcygl.web.interceptor;/** * Created by LittleXuan on 2015/8/31. */import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.sz.kcygl.common.DESUtil.MD5;import com.sz.kcygl.common.DESUtil.DESUtil;import net.sf.json.JSONObject;import org.apache.commons.lang.StringUtils;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import java.io.BufferedInputStream;/** * @author 赵宏轩 * 2015-08-31 */public class SignInterceptor extends HandlerInterceptorAdapter &#123; protected final Log log = LogFactory.getLog(this.getClass()); /** * 在业务处理器处理请求之前被调用 * 如果返回false * 从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链 * 如果返回true */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestUri = request.getRequestURI(); String contextPath = request.getContextPath(); String url = requestUri.substring(contextPath.length()); log.info("requestUri:" + requestUri); log.info("contextPath:" + contextPath); log.info("url:" + url); StringBuffer requestData=new StringBuffer(); BufferedInputStream buf = new BufferedInputStream(request.getInputStream()); byte[] buffer=new byte[1024]; int iRead; while((iRead=buf.read(buffer))!=-1)&#123; requestData.append(new String(buffer,0,iRead,"utf-8")); &#125; JSONObject jsonObject = JSONObject.fromObject(requestData.toString()); String requestDES = jsonObject.getString("requestMessage"); String signvalue = jsonObject.getString("sign"); log.info("加密后的字符串："+requestDES); log.info("MD5签名："+signvalue); String afterDES=""; if(StringUtils.isNotEmpty(requestDES))&#123; afterDES = DESUtil.decodeValue("tiananapp", requestDES); log.info("解密后请求："+afterDES); &#125; MD5 md5 =new MD5(); String localSign = md5.getMD5ofStr("tiananapp"+afterDES); log.info("本地MD5签名："+localSign); if(signvalue!=null&amp;&amp;signvalue.equalsIgnoreCase(localSign))&#123; request.setAttribute("requestMessage",afterDES); //将解密后的请求参数还原 return true; &#125; return false; &#125;&#125; 在Spring MVC 配置文件添加拦截器配置12345678&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 匹配的是url路径， 如果不配置或/**,将拦截所有的Controller --&gt; &lt;mvc:mapping path="/**" /&gt; &lt;mvc:exclude-mapping path="/front/**"/&gt;&lt;!-- 匹配的是不需要拦截的url路径&gt; &lt;bean class="com.sz.kcygl.web.interceptor.SignInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ajaxFileUpload异步上传图片]]></title>
    <url>%2F2015%2F08%2F20%2Fjs-use-ajaxFileUpload%2F</url>
    <content type="text"><![CDATA[今天是七夕，乞巧节快乐！！ 虽然最近学Python很入迷，但是前端的还是不能落下,加油。 使用之前，前端需要引入jquery以及ajaxfileupload.js 前端代码 123456789101112131415161718192021222324252627282930313233343536373839&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;!-- 引用jquery --&gt; &lt;!-- 引用ajaxfileupload.js --&gt; &lt;script type="text/javascript" src="/appService/js/jquery-1.8.3.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/appService/js/ajaxfileupload.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; //选择文件之后执行上传 $('#fileToUpload').on('click', function() &#123; $.ajaxFileUpload(&#123; url:'/appService/fileupload', secureuri:false, fileElementId:'fileToUpload',//file标签的id dataType: 'json',//返回数据的类型 success: function (data, status) &#123; $('#image').attr('src',data.urlImage); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img id="image" style="width: 200px; height: 200px" &gt;&lt;input id="fileToUpload" type="file" name="upfile"&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 后台采用的是Spring MVC处理文件的方式，需要引入spring-web-3.2.4.RELEASE.jar以及 commons-fileupload-1.3.1.jar两个包 后台处理代码： 123456789101112131415161718192021222324252627282930@RequestMapping("/fileupload") public void deleteImg(HttpServletRequest request,HttpServletResponse response) throws IOException &#123; //需要返回的fileName String fileName = null; boolean isMultipart = ServletFileUpload.isMultipartContent(request); if(isMultipart)&#123; MultipartHttpServletRequest multiRequest=(MultipartHttpServletRequest)request; MultipartFile file= multiRequest.getFile("upfile"); // 获得文件名： String filename = file.getOriginalFilename(); // 获得输入流： InputStream input = file.getInputStream(); // 写入文件 String realPath = this.getServletContext().getRealPath("/images"); FileOutputStream fos = new FileOutputStream(realPath+File.separator+filename); byte[] b = new byte[1024]; while((input.read(b)) != -1)&#123; fos.write(b); &#125; input.close(); fos.close(); //返回结果 JSONObject obj = new JSONObject(); obj.put("urlImage", realPath+File.separator+filename); response.getWriter().print(obj.toString()); &#125;]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据WebMagic写的一个爬取煎蛋网的小爬虫]]></title>
    <url>%2F2015%2F08%2F12%2Fwebmagic-java-jandanspider%2F</url>
    <content type="text"><![CDATA[之前研究jsoup，想用jsoup写一个小爬虫，爬煎蛋网的无聊图，我也是够无聊的 =.=,挖了个坑过了半个月还没填上，昨天上知乎的时候，发现有更加好用的爬虫框架WebMagic（知乎，果然让人发现更大的世界），先用WebMagic实现一下我的小爬虫，好啦，填坑开始… 这里用到webmagic，就把webmagic介绍，使用方法都放出来，没用过的先熟悉一下。 这里是WebMagic中文使用文档，一点即达 @.@ 介绍文档已经很详细了，下面开始，生产爬虫 分析煎蛋网无聊图html源码下面是煎蛋网无聊图页面的html源码片段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 &lt;div id="content"&gt; &lt;h1 class="title"&gt;无聊图&lt;/h1&gt; &lt;!-- begin comments --&gt; &lt;div id="comments"&gt; &lt;div style="clear:both;"&gt;&lt;/div&gt; &lt;h3 class="title" id="comments"&gt;TOTAL COMMENTS: 177,359&lt;span class="plusone"&gt;&lt;a href="#respond" title="来一发"&gt;+1&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; &lt;span class="break"&gt;&lt;/span&gt; &lt;div class="comments"&gt; &lt;div class="cp-pagenavi"&gt;&lt;span class="current-comment-page"&gt;[7095]&lt;/span&gt; &lt;a href="http://jandan.net/pic/page-7094#comments"&gt;7094&lt;/a&gt; &lt;a href="http://jandan.net/pic/page-7093#comments"&gt;7093&lt;/a&gt; &lt;a class="previous-comment-page" href="http://jandan.net/pic/page-7094#comments" title="Older Comments"&gt;&amp;raquo;&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;ol class="commentlist" style="list-style-type: none;"&gt; &lt;li id="comment-2894921"&gt; &lt;div&gt; &lt;div class="row"&gt; &lt;div class="author"&gt;&lt;strong title="防伪码：8d6a6ef3b33b2280a7c0803dc5cb97977799cbd2"&gt;不发表评论&lt;/strong&gt; &lt;br&gt; &lt;/div&gt; &lt;div class="text"&gt;&lt;span class="righttext"&gt;&lt;a href="http://jandan.net/pic/page-7095#comment-2894921"&gt;177358&lt;/a&gt;&lt;/span&gt;&lt;p&gt;&lt;img src="http://ww3.sinaimg.cn/mw600/a801236bjw1euyksy43o7j20f20qo40d.jpg" /&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;span class="break"&gt;&lt;/span&gt;&lt;/div&gt; &lt;/li&gt; &lt;li id="comment-2894895"&gt; &lt;div&gt; &lt;div class="row"&gt; &lt;div class="author"&gt;&lt;strong title="防伪码：10d69593001a14fc2189787eb1a0315113ff1714"&gt;delectate&lt;/strong&gt; &lt;br&gt; &lt;small&gt;&lt;a href="#footer" title="@回复" onclick="document.getElementById('comment').value += &amp;#39;@&amp;lt;a href=&amp;quot;http://jandan.net/pic/page-7095#comment-2894895&amp;quot;&amp;gt;delectate&amp;lt;/a&amp;gt;: &amp;#39;"&gt;@37 mins ago&lt;/a&gt;&lt;/span&gt;&lt;/small&gt; &lt;/div&gt; &lt;div class="text"&gt;&lt;span class="righttext"&gt;&lt;a href="http://jandan.net/pic/page-7095#comment-2894895"&gt;177352&lt;/a&gt;&lt;/span&gt;&lt;p&gt;老规矩，坟请猛x，谢谢。&lt;br /&gt;&lt;img src="http://ww2.sinaimg.cn/thumbnail/0066UPGbjw1euyrnitpbzg30b404gx6p.gif" org_src="http://ww2.sinaimg.cn/mw1024/0066UPGbjw1euyrnitpbzg30b404gx6p.gif" onload="add_img_loading_mask(this, load_sina_gif);"/&gt;&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;span class="break"&gt;&lt;/span&gt;&lt;/div&gt; &lt;/li&gt; &lt;/ol&gt; &lt;div class="comments"&gt; &lt;div class="cp-pagenavi"&gt;&lt;span class="current-comment-page"&gt;[7095]&lt;/span&gt; &lt;a href="http://jandan.net/pic/page-7094#comments"&gt;7094&lt;/a&gt; &lt;a href="http://jandan.net/pic/page-7093#comments"&gt;7093&lt;/a&gt; &lt;a class="previous-comment-page" href="http://jandan.net/pic/page-7094#comments" title="Older Comments"&gt;&amp;raquo;&lt;/a&gt;&lt;/div&gt; &lt;h3&gt; &lt;p id="respond"&gt;发表评论&lt;/p&gt; &lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- END wrapper --&gt;&lt;/body&gt;&lt;/html&gt; 先理一下思路 爬取无聊图首页图片想要爬的图片路径在div[id=content]-&gt;div[id=’comments’]-&gt;ol[class=commentlist]-&gt;li[id=’xxxx’]-&gt;div-&gt;div[class=’row’]-&gt;…-&gt;img[src]img的src链接就是静态图片的url，如果是动态图gif的话，那么org_src才是图片的真正url，src只是对应缩略图的url让爬虫选中列表项列表li，然后遍历每个li,然后取每个li的图片url和title, 保存图片到本地用httpclient根据图片url下载该图片保存在本地就行了 爬取下一页图片找到本页的下一页标签，从上面的源码片段可以看到是class=&quot;previous-comment-page&quot;的a标签当爬虫爬完首页时，接下来爬上一页，煎蛋网是倒序的… 开始编写爬虫首先，新建一个解析图片的Processor类新建一个PicProcessor类，继承自PageProcessor，并重写process方法 第一步，先处理首页图片1234567891011121314151617181920212223242526272829303132//处理图片类 private void processPicture(Page page) &#123; //得到所有Gif的li标签 List&lt;String&gt; gifLists = page.getHtml().xpath("//ol[@class='commentlist']/li[@id]").all(); for (String gif:gifLists)&#123; //得到标题 String title=xpath("//div[@class='author']/strong").selectElement(gif).attr("title"); logger.info("title:"+title); //得到上传者 String author=xpath("//div[@class='author']/strong").selectElement(gif).text(); //将标题中的防伪码转换为：上传者名称 title=title.replace("防伪码",author); //图片url //如果有org_src属性，则是gif图片 String url=xpath("//div[@class='text']/p/img").selectElement(gif).attr("src"); String gifUrl=xpath("//div[@class='text']/p/img").selectElement(gif).attr("org_src"); if(StringUtils.isNotEmpty(gifUrl))&#123; logger.info("Gif图片...替换新链接..."); url=gifUrl;//如果是gif则用大图链接替换缩略图链接 &#125; logger.info("图片url:" + url); //保存图片到本地 String filePath=downloadDir+ File.separator+author; String picType=url.substring(url.length()-3); try &#123; FileUtil.downloadFile(url,filePath,title, picType); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 保存图片的工具类代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.zeusjava.jandan.util;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.log4j.Logger;import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;/** * Created by LittleXuan on 2015/8/11. * 文件操作工具类 */public class FileUtil &#123; private static Logger logger = Logger.getLogger(FileUtil.class); /** * 下载文件 * * @param url * 文件http地址 * @param filePath * 目标文件路径 * @param fileName * 目标文件 * @param picType * 文件类型 * @throws java.io.IOException */ public static synchronized void downloadFile(String url,String filePath, String fileName,String picType) throws Exception &#123; logger.info("----------------------下载文件开始---------------------"); CloseableHttpClient httpclient = HttpClients.createDefault(); if (url == null || "".equals(url)) &#123; return; &#125; //目标目录 File desPathFile = new File(filePath); if (!desPathFile.exists()) &#123; desPathFile.mkdirs(); &#125; //得到文件绝对路径 String fullPath =filePath +File.separator+fileName+"."+picType; logger.info("文件路径："+filePath); logger.info("文件名："+fileName); logger.info("源文件url："+url); //从元网址下载图片 HttpGet httpget = new HttpGet(url); HttpResponse response = httpclient.execute(httpget); HttpEntity entity = response.getEntity(); InputStream in = entity.getContent(); //设置下载地址 File file = new File(fullPath); try &#123; FileOutputStream fout = new FileOutputStream(file); int l = -1; byte[] tmp = new byte[1024]; while ((l = in.read(tmp)) != -1) &#123; fout.write(tmp,0,l); &#125; fout.flush(); fout.close(); &#125; finally &#123; in.close(); &#125; logger.info("----------------------下载文件结束---------------------"); &#125;&#125; 爬取下一页123456789101112131415@Override public void process(Page page) &#123; System.out.println("================================"); //定义抽取信息，并保存信息 processPicture(page); //得到下一页链接 String comments=page.getHtml().xpath("//a[@class='previous-comment-page']").toString(); logger.info("comments:"+comments); String link = xpath("a/@href").select(comments); logger.info("link:" + link); Request request = new Request(link); page.addTargetRequest(request); System.out.println("================================"); &#125; 网站信息配置12345//得到网站配置 private Site site = Site.me().setDomain("jandan.net").addHeader("Accept", "application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*") .addHeader("Referer", "http://jandan.net/pic").setSleepTime(10000).setUserAgent("zhaohongxuan") .addStartUrl("http://jandan.net/pic"); 这里注意的是，要设置UserAgent，之前没加代理，刚开始启动程序可以爬，后来，煎蛋网就给屏蔽了，HttpClient返回HTTP/1.1 302 Moved Temporarily，煎蛋网把请求给重定向了设置SleepTime可以设置每次爬取之间的时间间隔，我写的是10000ms，即程序爬完一页之后休息10s继续爬下一页。 编写程序入口12345678public class JanDanSpiderTest &#123; private static Logger logger = Logger.getLogger(JanDanSpiderTest.class); public static void main(String[] args) &#123; PropertyConfigurator.configure(ClassLoader.getSystemResourceAsStream("log4j.properties")); Spider.create(new PicProcessor()).scheduler(new PriorityScheduler()).run(); &#125;&#125; 由于WebMagic采用的是链式编程，可以很方便的进行配置，上面我默认用的是PriorityScheduler，当然也可以使用多线程，使用thread()括号里写上Thread的数量就行了 1Spider.create(new PicProcessor()).scheduler(new PriorityScheduler()).thread(10).run(); 本程序源代码请戳JanDanSpider…]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xpath语法学习]]></title>
    <url>%2F2015%2F08%2F11%2Fxml-xpath-learning%2F</url>
    <content type="text"><![CDATA[最近写爬虫时，需要解析html，有好多种选择xml文档节点的方法，先熟悉一下使用xpath来选取节点、解析节点 下面是学习需要的XML文档 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bookstore&gt;&lt;book&gt; &lt;title lang="eng"&gt;Harry Potter&lt;/title&gt; &lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;&lt;book&gt; &lt;title lang="eng"&gt;Learning XML&lt;/title&gt; &lt;price&gt;39.95&lt;/price&gt;&lt;/book&gt;&lt;/bookstore&gt; 选取节点XPath使用路径表达式在XML文档中选取节点。节点是通过沿着路径或者step来选取的。 最有用的路径表达式如下： nodename 选取此节点的所有子节点。/ 从根节点选取。// 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。. 选取当前节点。.. 选取当前节点的父节点。@ 选取属性。 ####实例 bookstore 选取 bookstore 元素的所有子节点。 /bookstore 选取根元素 bookstore。 注意：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ bookstore/book 选取属于 bookstore 的子元素的所有 book 元素。 //book 选取所有 book 子元素，而不管它们在文档中的位置。 bookstore//book 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 //@lang 选取名为 lang 的所有属性。 谓语（Predicates）谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号中。 实例/bookstore/book[1] 选取属于 bookstore 子元素的`第一个` book 元素。 /bookstore/book[last()] 选取属于 bookstore 子元素的`最后一个` book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的`倒数第二个` book 元素。 /bookstore/book[position()&lt;3] 选取`最前面的两个`属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取`所有`拥有名为`lang的属性`的 title 元素。 //title[@lang='eng'] 选取`所有` title 元素，且这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price&gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须`大于` 35.00。 /bookstore/book[price&gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 选取未知节点XPath 通配符可用来选取未知的 XML 元素。* 匹配任何元素节点。@* 匹配任何属性节点。node() 匹配任何类型的节点。 实例/bookstore/* 选取 bookstore 元素的所有`子元素`。 //* 选取文档中的`所有元素`。 //title[@*] 选取所有带有属性的`title`元素。 选取若干路径通过在路径表达式中使用`|运算符，您可以选取若干个路径。 实例//book/title | //book/price 选取 book 元素的所有 title 和 price 元素。 //title | //price 选取文档中的所有 title 和 price 元素。 /bookstore/book/title | //price 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用花生壳搭建微信公众号的本地测试环境]]></title>
    <url>%2F2015%2F08%2F05%2Fwechat-debug-in-local-environment-2%2F</url>
    <content type="text"><![CDATA[前天用ngrok这个软件来代理转发微信请求本地微信环境的数据，但是二级域名每重启一次服务就会改变，实在是很不爽，以前ngrok的二级域名也是免费的，可能用的人多了，就给整收费了吧，现在用新花生壳再一次搭建一个本地开发的微信环境，其实这个严格来说也不是免费的，因为会收取一块钱的短信验证费用 ^_^。 搭建步骤一、登录花生壳官网，没有注册的用户点击注册，注册新用户 二、点击管理中心，进入我的花生壳，点击添加帐号，添加新的帐号应该会有一个默认帐号，点击默认帐号，会出现域名列表，如果没有域名的话，点击添加域名，创建一个花生壳的二级域名 三、登录花生壳官网下载新花生壳 四、安装花生壳双击下载的安装包，安装到本机上 五、登录上新花生壳客户端，双击选中的账户输入注册好的用户和密码登录上新花生壳客户端 六、在弹出的窗口中将内网映射选项打开，那个外网访问地址就是在微信后台配置的接口地址如果是首次使用的话，内网映射应该是打不开的，需要激活才能使用，激活步骤转到步骤七 七、打开 http://www.oray.com/activity/140902/ 可以通过三种方式开通内网映射在这里选择短信激活，会收取一块钱费用，如果长时间没有收到验证码，也可以通过支付宝支付一块钱激活。激活之后就可以在打开新花生壳上的内网映射选项应该可以打开了，如果打不开的情况，重启一下新花生壳就能登上了 八、进入微信公众平台后台接口配置信息中，配置服务器URL 九、本地启动Tomcat服务器，微信发送一个消息，控制台就会打印微信发过来的消息在微信客户端发送了一个赵小轩的消息，在本地控制台就会打印微信推送过来的消息，以后就可以实时和微信联调了，也就是微信开发本地环境搭建成功了。]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建微信公众号的本地测试环境]]></title>
    <url>%2F2015%2F08%2F03%2Fwechat-debug-in-local-environment%2F</url>
    <content type="text"><![CDATA[一般情况下，我们在开发微信公众平台的时候，流程一般是这样的 本地编码 提交测试服务器测试，测试环境一般绑定一个测试号 测试通过后发布生产环境代码 但是这样会非常不方便调试代码，还好有法宝，可以在本地模拟一个测试环境，把微信转发给测试环境的的请求全部都转发给本地，其实还可以换种思路，只要将本地的ip地址暴露在公网上，就可以和微信服务器进行交互了。首先你需要一个把本地ip地址暴露在公网上的软件，目前主流而且免费的一般用ngrok 搭建本地环境的步骤如下:登录链接名称（可能需要科学上网）注册用户，会得到一个token 下载ngrok，解压并运行ngrok.exe，认证token 开启指定端口的http服务 把本地端口换成ngrok的域名 在微信公众号后台把接口配置信息改为刚才替换掉的ngrok域名 这样一个微信公众平台本地测试环境就搭好了，用户和微信交互时微信服务器发送的消息都将会转发到本地Tomcat服务器，但是还有一点不爽这个域名是随机分配到，就是说如果你按下ctrl+C结束了程序，再次启动的话，域名还是会变掉，想得到固定的二级域名，就必须要花钱了一个月5美元。]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信OAuth2.0鉴权获取用户信息]]></title>
    <url>%2F2015%2F04%2F22%2Fwechat-get-userinfo%2F</url>
    <content type="text"><![CDATA[在微信开发中经常需要在网页中获取用户的基本信息，和UnionID机制获取用户信息的方式不同,这种方式可以得到未关注本微信号的人的基本信息。 首先第一步要在微信公众平台上配置回调域名，注意域名不是URL，不要包涵http://等协议头 开发步骤1.用户同意授权，获取code在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），引导关注者打开如下页面： https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect redirect_uri是授权后重定向的回调链接地址，请使用urlencode对链接进行处理response_type是返回类型，请填写codescope是应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且，即使在未关注的情况下，只要用户授权，也能获取其信息）state否重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节#wechat_redirect无论直接打开还是做页面302重定向时候，必须带此参数 用户同意授权后如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE。若用户禁止授权，则重定向后不会带上code参数，仅会带上state参数redirect_uri?state=STATE code说明 ： code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，`5分钟`未被使用自动过期。 拼接授权连接Java代码 1234public static String getMenuOauthUrl(String appId,String url,String state)&#123; String authUrl="https://open.weixin.qq.com/connect/oauth2/authorize?appid="+appId+"&amp;redirect_uri="+url+"&amp;response_type=code&amp;scope=snsapi_base&amp;state="+state+"#wechat_redirect"; return authUrl;&#125; snsapi_base可以改为snsapi_userinfo可以得到用户所有的信息，否则只能获得openId 2.通过code换取网页授权access_token首先请注意，这里通过code换取的是一个特殊的网页授权access_token,与基础支持中的access_token（该access_token用于调用其他接口）不同。公众号可通过下述接口来获取网页授权access_token。如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。 请求方法 获取code后，请求以下链接获取access_token： https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code code填写第一步获取的code参数grant_type填写为authorization_code得到AccessToken代码 1234567891011121314151617181920212223242526272829303132333435public static Map&lt;String,String&gt; getCodeAccessToken(String appid, String secret, String code)&#123; Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;(); if (StringUtils.isBlank(appid) || StringUtils.isBlank(secret) || StringUtils.isBlank(code)) &#123; return map; &#125; StringBuilder sb = new StringBuilder("https://api.weixin.qq.com/sns/oauth2/access_token"); sb.append("?appid=").append(appid).append("&amp;secret=").append(secret); sb.append("&amp;code="+code).append("&amp;grant_type=authorization_code"); String result = HttpClientUtil.getRequest(sb.toString(), "","UTF-8", "text/html"); logger.info("result:"+result); if (StringUtils.isNotEmpty(result)) &#123; JSONObject jo = JSON.parseObject(result); String errcode = jo.getString("errcode"); String errmsg = jo.getString("errmsg"); if (StringUtils.isNotEmpty(errcode)) &#123; //出错了 logger.info("clll wx error,errcode=" + errcode + ", errmsg=" + errmsg); map.put("errcode", errcode); map.put("errmsg",errmsg); &#125; else &#123; String access_token = jo.getString("access_token");//访问凭证 String expires_in = jo.getString("expires_in");//凭证有效时间 String refresh_token = jo.getString("refresh_token");//用户刷新access_token String openid = jo.getString("openid"); String scope = jo.getString("scope"); map.put("access_token",access_token); map.put("expires_in",expires_in); map.put("refresh_token",refresh_token); map.put("openid",openid); map.put("scope",scope); &#125; &#125; return map; &#125; 如果Scope为基本信息的话，那么本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。 12345678910111213141516/** * 获取openId * @param request * @return * @throws Exception */public String getOpenId(HttpServletRequest request) throws Exception &#123; String appid = PropertiesLoader.getPropertiesByName("appId"); String appSerect = PropertiesLoader.getPropertiesByName("secret"); String code = this.getParameter(request, "code"); Map&lt;String, String&gt; map = AccessTokenUtil.getCodeAccessToken(appid, appSerect, code); String openid = map.get("openid"); String state = this.getParameter(request, "state"); return openid;&#125; 3.拉取用户信息(需scope为 snsapi_userinfo)如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息请求方法http：GET（请使用https协议） https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN 得到微信返回的报文 123456public static String getBaseUserInfoAPI(String accessToken, String openId)&#123; logger.info("进入获取用户信息(snsapi_base)API方法"); String reqUrl = WeiXinUrlUtil.getBaseUserInfoUrl(accessToken, openId); String resDoc = HttpClientUtil.getRequestHandler(reqUrl, "", "获取用户信息"); return resDoc; &#125; 将报文转换为自己需要的Object即可]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB2根据条件Update数据!]]></title>
    <url>%2F2015%2F04%2F15%2Fdb2-update-case%2F</url>
    <content type="text"><![CDATA[DB2根据条件Update1234567891011121314UPDATE employee SET salary= CASE WHEN workyear&lt; THEN 0.05 WHEN area&lt;20000 THEN 0.07 ELSE 0.09 END UPDATE properities SET taxrate= CASE WHEN area&lt;10000 THEN 0.05 WHEN area&lt;20000 THEN 0.07 ELSE 0.09 END]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>db2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查询oracle中clob中的xml的节点数据]]></title>
    <url>%2F2015%2F04%2F15%2Foracle-clob-xmltype%2F</url>
    <content type="text"><![CDATA[查询oracle中clob中的xml的节点数据查询xmltype字段里面的内容现在有一个EBIZ_THIRD_TRADE(第三方交易)表里面有一个TRADE_REQUEST_CONTENT返回报文字段类型为clob下面的一个示例返回报文xml： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version="1.0" encoding="GBK" standalone="yes"?&gt;&lt;PackageList xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; &lt;Package&gt; &lt;Header&gt; &lt;RequestType&gt;01&lt;/RequestType&gt; &lt;UUID&gt;55435745-11d8-44a3-addf-8ba269385446&lt;/UUID&gt; &lt;ComId&gt;2243411990&lt;/ComId&gt; &lt;From&gt;taobao&lt;/From&gt; &lt;SendTime&gt;2015-04-15 11:48:41&lt;/SendTime&gt; &lt;TaoBaoSerial&gt;10923265164636660&lt;/TaoBaoSerial&gt; &lt;ComSerial xsi:nil="true"/&gt; &lt;Asyn&gt;0&lt;/Asyn&gt; &lt;ReturnUrl&gt;http://service.baoxian.taobao.com/baoxian/cooperation&lt;/ReturnUrl&gt; &lt;ProductCode&gt;17&lt;/ProductCode&gt; &lt;/Header&gt; &lt;Request&gt; &lt;Order&gt; &lt;TBOrderId&gt;10923265164636660&lt;/TBOrderId&gt; &lt;TotalPremium&gt;200&lt;/TotalPremium&gt; &lt;PostFee xsi:nil="true"/&gt; &lt;InsBeginDate&gt;2015-04-17 00:00:00&lt;/InsBeginDate&gt; &lt;InsEndDate&gt;2015-04-18 00:00:00&lt;/InsEndDate&gt; &lt;InsPeriod&gt;1D&lt;/InsPeriod&gt; &lt;ApplyNum&gt;1&lt;/ApplyNum&gt; &lt;Item&gt; &lt;ItemId&gt;43574889020&lt;/ItemId&gt; &lt;SkuRiskCode&gt;17&lt;/SkuRiskCode&gt; &lt;ProductCode&gt;17&lt;/ProductCode&gt; &lt;ProductName&gt;平台险&lt;/ProductName&gt; &lt;Amount xsi:nil="true"/&gt; &lt;Premium&gt;200&lt;/Premium&gt; &lt;ActualPremium&gt;200&lt;/ActualPremium&gt; &lt;DiscountRate&gt;10000&lt;/DiscountRate&gt; &lt;/Item&gt; &lt;PolicyNo xsi:nil="true"/&gt; &lt;/Order&gt; &lt;ApplyInfo&gt; &lt;Holder&gt; &lt;CustomList&gt; &lt;Custom key="HolderBirthday"&gt;1986-01-03&lt;/Custom&gt; &lt;Custom key="HolderName"&gt;周燕霞&lt;/Custom&gt; &lt;Custom key="HolderMobile"&gt;18907099975&lt;/Custom&gt; &lt;Custom key="HolderSex"&gt;2&lt;/Custom&gt; &lt;Custom key="HolderCardType"&gt;1&lt;/Custom&gt; &lt;Custom key="HolderCardNo"&gt;360121198601032426&lt;/Custom&gt; &lt;/CustomList&gt; &lt;/Holder&gt; &lt;InsuredInfo&gt; &lt;IsHolder&gt;0&lt;/IsHolder&gt; &lt;InsuredList&gt; &lt;Insured&gt; &lt;CustomList&gt; &lt;Custom key="InsuredName"&gt;万俊&lt;/Custom&gt; &lt;/CustomList&gt; &lt;BenefitInfo&gt; &lt;IsLegal&gt;1&lt;/IsLegal&gt; &lt;BenefitList/&gt; &lt;/BenefitInfo&gt; &lt;/Insured&gt; &lt;/InsuredList&gt; &lt;/InsuredInfo&gt; &lt;OtherInfo&gt; &lt;CustomList/&gt; &lt;/OtherInfo&gt; &lt;RefundInfo&gt; &lt;CustomList/&gt; &lt;/RefundInfo&gt; &lt;/ApplyInfo&gt; &lt;/Request&gt; &lt;/Package&gt;&lt;/PackageList&gt; 要得到其中的&lt;Custom key=&quot;InsuredName&quot;&gt;万俊&lt;/Custom&gt;里的万俊名字 1234select THIRD_TRADE_ID,extract(xmltype(TRADE_REQUEST_CONTENT),'/PackageList/Package/Request/ApplyInfo/InsuredInfo/InsuredList/Insured/CustomList/Custom/text()').getStringVal() insurename from EBIZ_THIRD_TRADE where third_trade_id i='10923296687106660';]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 数据类型绑定]]></title>
    <url>%2F2015%2F04%2F14%2Fspringmvc-data-binding%2F</url>
    <content type="text"><![CDATA[今天遇到一个问题，使用Spring MVC 从页面传递一个用户List到Controller，然后再后台解析List得到多个用户对象，在网上搜了很多答案感觉都不行,后来调试代码发现，最关键在于:List需要绑定在对象(ActionForm),直接写在request-mapping函数的参数是不行的,更重要的一点是要创建对象(ArrayList)。 之前的Jsp代码是这么写的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;form action="insertInsureUser.do" method="post"&gt; &lt;div class="form_left"&gt;开始时间:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.startTime"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;产品代码:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.productCode"/&gt; &lt;h2&gt;投保人信息&lt;/h2&gt; &lt;/div&gt; &lt;div class="form_left"&gt;姓名:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[0].startTime"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;身份证号:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[0].idCard"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;性别:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[0].sex"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;地址:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[0].address"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;邮箱:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[0].email"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;电话号码:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[0].phone"/&gt; &lt;/div&gt; &lt;h2&gt;被保人信息&lt;/h2&gt; &lt;/div&gt; &lt;div class="form_left"&gt;姓名:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[1].startTime"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;身份证号:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[1].idCard"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;性别:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[1].sex"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;地址:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[1].address"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;邮箱:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[1].email"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;电话号码:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureObject.insureUser[1].phone"/&gt; &lt;/div&gt;&lt;/form&gt; controller代码 1234567891011@RequestMapping("/insertInsureUser.do") public String queryAppUserGroup(HttpServletRequest request, HttpServletResponse response, ModelMap model, @ModelAttribute("insureObject") InsureUserQueryObject insureObject) throws Exception &#123; logger.info("=======List类型数据绑定======"); if(insureObject!=null&amp;&amp;insureObject.getInsureUsers.size()&gt;0)&#123; for(InsureUser insureUser:insureObject)&#123; System.out.println(insureUser.getName()); &#125; &#125; &#125; 网上很多人都给不出答案,关键在于,List需要绑定在对象(ActionForm),直接写在request-mapping函数的参数是不行的,更重要的一点是要创建对象(ArrayList).实体InsureUserQueryObject代码 1234567891011121314151617181920212223242526272829public class InsureUserQueryObject &#123; private String startTime;//起始时间 private String productCode;//产品代码 private List&lt;InsureUser&gt; insureUsers;//投保人被保人 public String getStartTime() &#123; return startTime; &#125; public void setStartTime(String startTime) &#123; this.startTime = startTime; &#125; public String getProductCode() &#123; return productCode; &#125; public void setProductCode(String productCode) &#123; this.productCode = productCode; &#125; public List&lt;InsureUser&gt; getInsureUsers() &#123; return insureUsers; &#125; public void setInsureUsers(List&lt;InsureUser&gt; insureUsers) &#123; this.insureUsers = insureUsers; &#125;&#125; List中要用到的InsureUser代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class InsureUser &#123; private String name;//姓名 private String idCard;//身份证号 private String sex;//性别 private String address;//地址 private String email;//邮箱 private String phone;//电话号码 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getIdCard() &#123; return idCard; &#125; public void setIdCard(String idCard) &#123; this.idCard = idCard; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125;&#125; 后来发现，控制台报属性不存在异常，查资料后发现，Spring MVC 数据绑定和struts是不一样的，o(╯□╰)o，表单前面不需要添加实体对象insureObject,把insureObject删除掉更改过后的jsp代码为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;form action="insertInsureUser.do" method="post"&gt; &lt;div class="form_left"&gt;开始时间:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="startTime"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;产品代码:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="productCode"/&gt; &lt;h2&gt;投保人信息&lt;/h2&gt; &lt;/div&gt; &lt;div class="form_left"&gt;姓名:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[0].startTime"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;身份证号:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[0].idCard"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;性别:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[0].sex"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;地址:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[0].address"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;邮箱:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[0].email"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;电话号码:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[0].phone"/&gt; &lt;/div&gt; &lt;h2&gt;被保人信息&lt;/h2&gt; &lt;/div&gt; &lt;div class="form_left"&gt;姓名:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[1].startTime"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;身份证号:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[1].idCard"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;性别:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[1].sex"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;地址:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[1].address"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;邮箱:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[1].email"/&gt; &lt;/div&gt; &lt;div class="form_left"&gt;电话号码:&lt;/div&gt; &lt;div class="form_right"&gt; &lt;input name="insureUser[1].phone"/&gt; &lt;/div&gt; &lt;/form&gt; 但是发现更改过后还是有异常，数组越界异常啊摔，原来是页面在向InsureUserQueryObject的对象写数据时发现List列表是空的，于是在InsureUserQueryObject中给List赋一个ArrayList的初值，添加一个默认构造函数，在构造函数中向列表中添加一个两个InsureUser用来存储页面传过来的InsureUser对象 大功告成！！修改过后的InsureUserQueryObject 12345678910111213141516171819202122232425262728293031323334 public class InsureUserQueryObject &#123; private String startTime;//起始时间 private String productCode;//产品代码 private List&lt;InsureUser&gt; insureUsers = new ArrayList&lt;InsureUser&gt;();//投保人被保人 public InsureUserQueryObject() &#123;InsureUser user1=new InsureUser();InsureUser user2=new InsureUser();insureUsers.add(user1);//添加投保人insureUsers.add(user2);//添加被保人 &#125; public String getStartTime() &#123; return startTime; &#125; public void setStartTime(String startTime) &#123; this.startTime = startTime; &#125; public String getProductCode() &#123; return productCode; &#125; public void setProductCode(String productCode) &#123; this.productCode = productCode; &#125; public List&lt;InsureUser&gt; getInsureUsers() &#123; return insureUsers; &#125; public void setInsureUsers(List&lt;InsureUser&gt; insureUsers) &#123; this.insureUsers = insureUsers; &#125; &#125;]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用intellij IDEA]]></title>
    <url>%2F2015%2F04%2F12%2Fuse-intellijidea-instead-eclipse%2F</url>
    <content type="text"><![CDATA[intellij初体验据说是最好用的Java IDE，没有之一，吓得我赶紧下载来用用，果然第一次用好魔性，Darcula主题简直炫酷吊炸天，Github功能也集成了，可以直接分享项目到Github好方便有木有，工具可以直接连接SSH，对于经常需要连接SSH的人来说，简直幸福死，有了Terminal，妈妈再也不用担心我来回换窗口了，就像JetBrains公司的宣传语是这么说的：Develop with pleasure！让我们带着快乐编程吧~ 初体验之操作Java EE项目导入J2EE项目导入之前eclipse项目，点击File-&gt;Import Module选中之前的的J2EE项目，选择Import from extern model的eclipse然后点击next最后点击finish完成导入项目。 设置项目的库文件，想要项目运行，就需要添加项目需要的jar包啦，点击File-&gt;Project Structure进入项目结构界面，点击Module进入模块设置，点击绿色的+号，加入spring，web等模块 输出的war包设置项目打的war包的点击artifacts点击绿色的+,选择Web Application:Achieve也就是war包，点击output directory选择输出的路径 初体验之集成工具的使用Jboss的使用 点击Run -&gt;edit configration进入服务器设置 点击绿色的+选择Jboss server,选择local进入Jboss设置 点击Application server后面的configure选择Jboss的主目录，Intellij idea会自动搜索jboss下的jar包设置完主目录以后点击User alternative JRE选择JRE目录 点击server instance选择default作为当前的服务器实例 点击deployment选项卡，选择刚才所打的war包 点击完成，Jboss服务器就搭建好了。 点击工具栏的Run-&gt;Run weixin weixin是你设置的Jbosss服务器名，然后Jboss就启动起来了 =。=###SSH工具的使用点击菜单栏Tools-&gt;start SSH session-Edit credentials编辑你的服务器的IP端口等就可以登录服务器了。 2.intellij idea快捷键使用点击菜单栏Help-&gt;default keyMap reference会自动打开一个PDF，里面是当前快捷键的设置，如果英文好一点的话，看起来应该毫不费力实用快捷键: Ctrl+/ 行注释（// ） Ctrl+Shift+/块注释（*...*/ ） Ctrl+D 复制行 Ctrl+X 删除行 alt+enter 快速修复 alt+/ 代码提示 ctr+G 定位某一行 Shift+F6 重构-重命名 Ctrl+R 替换文本 Ctrl+F 查找文本 Ctrl+E 最近打开的文件 Ctrl+J 自动代码 Ctr+alt+O 组织导入 Ctr+alt+L 格式化代码 Ctr+shift+U 大小写转化 Alt+回车 导入包,自动修正 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 Ctrl+Alt+L 格式化代码 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等) Ctrl+E 最近更改的代码 Ctrl+R 替换文本 Ctrl+F 查找文本 Ctrl+Space 基本自动补全代码 Ctrl+Shift+Space 智能自动补全代码 Ctrl+Alt+Space 类名或接口名提示 Ctrl+P 方法参数提示 Ctrl+Shift+Alt+N 查找类中的方法或变量 Alt+Shift+C 对比最近修改的代码 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+J 自动代码 Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Ctrl+Alt+ left/right 返回至上次浏览的位置 Alt+ left/right 切换代码视图 Alt+ Up/Down 在方法间快速移动定位 Ctrl+Shift+Up/Down 代码向上/下移动。 F2 或Shift+F2 高亮错误或警告快速定位 Ctrl+Shift+F7 高亮显示所有该文本，按Esc高亮消失。 Ctrl+W 选中代码 Alt+F3 逐个往下查找相同文本，并高亮显示。 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>intellij</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常见命令!]]></title>
    <url>%2F2015%2F04%2F10%2Fbase-git-command%2F</url>
    <content type="text"><![CDATA[Git基本操作命令创建Git版本仓库在本地的任何一个空目录，通过git init把目录变成一个Git仓库 git init 添加文件到Git仓库git add &lt;file_name&gt; 提交文件到Git仓库git commit -m "&lt;commit_message&gt;" 显示提交日志git log [--pretty=oneline] 可以加上--pretty=oneline参数来减少输出的信息, git log --graph命令可以看到分支合并图。 回退上一个版本git reset --hard HEAD 上一个版本就是HEAD^，上上一个版本就是HEAD^^，如果版本号较多，可以写成HEAD~100。 查看命令日志git reflog 查看Git仓库状态git status 添加文件到暂存区git add 将暂存区文件提交到当前分支git commit 撤销修改git checkout --&lt;file_name&gt; 删除文件git rm &lt;file_name&gt; 远程仓库添加远程库在本地的仓库下面运行 $ git remote add origin git@github.com:javaor/javaor.github.io.git 将本地库内容推送到远程库上 git push [-u] origin master 其中-u参数会把本地的master分支和远程的master分支关联起来。 从远程仓库克隆$ git clone git@github.com:javaor/javaor.github.io.git 地址可使用SSH协议的git地址，也可以使用Https协议的地址 分支管理查看当前分支git branch 显示本地、服务器所有分支git branch -a 显示本地分支和服务器分支的映射关系git branch -vv 切换分支git checkout &lt;branch_name&gt; 创建新分支git checkout -b &lt;branch_name&gt; 提交本地分支代码到远端服务器git push origin &lt;remote_branch_name&gt; 如果远端服务器没有该分支，将会自动创建 更新远端分支代码到本地当前分支git pull origin master 合并分支到当前分支git merge &lt;branch_name&gt; 合并远程master分支到当前分支git merge origin/master 删除本地分支git checkout &lt;another_branch&gt; git branch -d &lt;branch_name&gt; 删除远程分支git push origin --delete &lt;branch_name&gt; 标签管理创建标签首先切换到要创建标签的分支 git tag &lt;tag_name&gt; 标签打在最新提交的commit上 查看标签git tag 查看标签详情git show tag &lt;tag_name&gt; 删除标签git tag -d &lt;tag_name&gt; 将标签推送至远程git push origin &lt;tag_name&gt; 使用git push origin --tags 推送所有标签到远程 删除远程标签删除远程标签需要先删除本地的标签，然后输入下面命令 git push origin :refs/tags/&lt;tagname&gt;]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel剔除一组数据]]></title>
    <url>%2F2015%2F04%2F07%2Fexcel-remove-the-same-data%2F</url>
    <content type="text"><![CDATA[Excel剔除重复数据假如我们现在有两组数据，其中一组数据为主数据A，另一组为子数据B，要将B从A中剔除形成一组新的数据C在下图中 A列为主列，B列为要从A列中去除的数据，C列为去除重复的新列 在C列第一个单元格内输入=IF(COUNTIF($B$2:$B$99,$A2)&gt;=1,&quot;&quot;,$A2)，当然，如果有更多的数据，99可以更改为更大的数据比如99999然后选中C列，按住键盘ctrl+G 选择空值]]></content>
      <categories>
        <category>办公软件</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【微信接口学习】基础接口]]></title>
    <url>%2F2015%2F04%2F04%2Fwechat-base-interface%2F</url>
    <content type="text"><![CDATA[获取access_tokenaccess_token是公众号的全局唯一票据，公众号调用各接口时都需使用access_token。 1. access_token的存储至少要保留512个字符空间。 2. access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。 3. 需要中控服务器定时获取和刷新access_token，而且还需要被动刷新access_token 接口调用请求说明 http请求方式: GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET 正常情况下，微信会返回下述JSON数据包给公众号： {"access_token":"ACCESS_TOKEN","expires_in":7200} 获取微信服务器的IP地址接口调用请求说明 http请求方式: GET https://api.weixin.qq.com/cgi-bin/getcallbackip?access_token=ACCESS_TOKEN 正常情况下，微信会返回下述JSON数据包给公众号： { "ip_list":["127.0.0.1","127.0.0.1"] } 上传和下载多媒体文件1. 对多媒体文件的操作是通过media_id来进行的 2. 每个多媒体文件在发送到服务器3天后自动删除 上传多媒体文件接口 调用请求说明 http请求方式: POST/FORM http://file.api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&amp;type=TYPE 调用示例（使用curl命令，用FORM表单方式上传一个多媒体文件）： curl -F media=@test.jpg "http://file.api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&amp;type=TYPE" 正确情况下的返回JSON数据包结果如下： {“type”:”TYPE”,”media_id”:”MEDIA_ID”,”created_at”:123456789}下载多媒体文件接口调用请求说明 http请求方式: GET http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID 请求示例（示例为通过curl命令获取多媒体文件） curl -I -G "http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID"]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎来到Javaor的代码空间!]]></title>
    <url>%2F2015%2F04%2F03%2Fthe-start-of-my-blog%2F</url>
    <content type="text"><![CDATA[每一天都是崭新的，在阳光下用力呼吸 世界好大，知识无涯，愿我能够在有生之年，能在知识的海洋多撷几枚贝壳 黑夜纵会漫长，过后便是黎明]]></content>
      <categories>
        <category>杂文其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Jekyll!]]></title>
    <url>%2F2015%2F04%2F01%2Fhello-jekyll%2F</url>
    <content type="text"><![CDATA[1. 标题与文字格式标题123456# 测试 h1## 测试 h2### 测试 h3#### 测试 h4##### 测试 h5###### 测试 h6 效果： 测试 h1测试 h2测试 h3测试 h4测试 h5测试 h6文字格式123**这是文字粗体格式***这是文字斜体格式*~~在文字上添加删除线~~ 这是文字粗体格式这是文字斜体格式在文字上添加删除线 2. 列表无序列表123* 项目1* 项目2* 项目3 项目1 项目2 项目3 有序列表123451. 项目12. 项目23. 项目3 * 项目1 * 项目2 项目1 项目2 项目3 项目1 项目2 3. 代码测试行代码： code 测试段落代码： 1234567/* hello world demo */#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; printf("Hello, World!\n"); return 0;&#125; 4. 表格123456|head1|head2|head3|head4|---|:---|---:|:---:||row1text1|row1text2|row1text3|row1text4|row2text1|row2text2|row2text3|row2text4|row3text1|row3text2|row3text3|row3text4|row4text1|row4text2|row4text3|row4text4 效果如下： head1 head2 head3 head4 row1text1 row1text2 row1text3 row1text4 row2text1 row2text2 row2text3 row2text4 row3text1 row3text2 row3text3 row3text4 row4text1 row4text2 row4text3 row4text4 5. 其他图片1![图片名称](/static/images/loading.gif) 链接12[链接名称](http://zeusjava.com)&lt;http://zeusjava.com&gt; 链接名称http://zeusjava.com 引用12&gt; 第一行引用文字&gt; 第二行引用文字 第一行引用文字第二行引用文字 水平线1*** 6. 其他资料 Jekyll 扩展的 Liquid 设计 Jekyll 扩展的 Liquid 模板]]></content>
      <categories>
        <category>杂文其他</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
      </tags>
  </entry>
</search>